// params set from jenkins job:
//performanceTests = true;
//deployDists = true;
//publishArtifacts = true;
//branchToBuild = "master";

//publishToDummy = true
// publishCommercial = true;

// TODO: remove minimal!
defaultGradleArgs = " -Pdist=minimal --info --stacktrace"


def branchName

import groovy.transform.Field

@Field
String jadexVersion

def versionSuffix

// convert parameters to booleans:
performanceTests = performanceTests.toBoolean()
publishArtifacts = publishArtifacts.toBoolean()
deployDists = deployDists.toBoolean()
publishToDummy = publishToDummy.toBoolean()
publishCommercial = publishCommercial.toBoolean()

resetPatchVersion = resetPatchVersion.toBoolean()

stage('preparation') {
    node { // a node is a step with workspace, can be distributed

        println """Build params: 
                branchToBuild: ${branchToBuild}, 
                performanceTests: ${performanceTests}, 
                publishArtifacts: ${publishArtifacts}, 
                publishToDummy: ${publishToDummy}, 
                publishCommercial: ${publishCommercial},
                deployDists: ${deployDists},
                resetPatchVersion: ${resetPatchVersion}"""

        git url: 'ssh://jenkins@repo.actoron.com:20000/repositories/jadex', branch: branchToBuild
        echo "testing jenkins with pipeline"

        branchName = sh(script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()
//        println "On branch: ${env.BRANCH_NAME}" // for multibranch projects, this works?
        println "On branch: ${branchName}"

        // parse last git tag
        def git_tag = sh(returnStdout: true, script: 'git describe --abbrev=0 --tags').trim()
        println "The tag used for generating a new version is: ${git_tag}"

        // current git tag:
//        git describe --abbrev=0 --tags --exact-match

        // find tag name of HEAD:

        String git_headTag = sh(returnStdout: true, script: 'git tag --points-at HEAD').trim()
        println git_headTag

        boolean headIsLastVersionTag = false
        def tags = runCmdAndSplit('git tag --points-at HEAD')
        for (int i = 0; i < tags.length; i++) {
            if (git_tag.equals(tags[i])) {
                headIsLastVersionTag = true
                println "The last tag that was found on this branch points at HEAD, so nothing new happened since then."
                timeout(time:1, unit: 'HOURS') {
                    input(id: 'noNewCommits', message: 'Do you want to proceed anyway? This will lead in publish and/or tag pushing errors!')
                }
            }
        }

        def versionsFromTag = getVersionsFromTag(git_tag);
        def patch = versionsFromTag.patch

        currentBuild.description = "build in branch: ${branchName}"

        if ("master".equals(branchName) || "stable".equals(branchName)) {
            // generate version continuously
            //def result = build job: "pipeline-generate-version-${branchName}"
            // needs whitelisting, see https://issues.jenkins-ci.org/browse/JENKINS-36528
            //genVersion = result.rawBuild.environment.PATCH_VERSION;

            patch = patch as Integer
            if (resetPatchVersion) {
                patch = 0;
            } else if (!headIsLastVersionTag) {
                // increase patch level if at least one commit is between last tag and HEAD
                patch++
            }
            versionSuffix = "${patch}"

        } else {
            Integer branchPatch
            if (versionsFromTag.branchName) {
                if (!versionsFromTag.branchName.equals(branchName)) {
                    error ("Something went wrong, expected last tag to be for branch: ${branchName}, but got tag: ${git_tag}")
                }
                branchPatch = versionsFromTag.branchPatch as Integer;
                if (!headIsLastVersionTag) {
                    // increase patch level if at least one commit is between last tag and HEAD
                    branchPatch++
                }
            } else {
                // no branch build yet
                branchPatch = 1
            }
            versionSuffix = "${patch}${branchName}-${branchPatch}"
            // so we append something to our version. but what?
            //versionSuffix = "${result.rawBuild.environment.PATCH_VERSION}${branchName}"
        }

        echo "version suffix:" + versionSuffix

        withEnv(['BUILD_VERSION_SUFFIX=' + versionSuffix]) {
            sh "./gradlew createVersionInfo"
            def props = readProperties file: 'build/jadexversion.properties'
            jadexVersion = props.jadexversion

            println "building version: ${jadexVersion}"
            currentBuild.displayName = "${jadexVersion}"

            sh './gradlew gendeplist'

            stash name: 'sources'
            stash includes: '.git/**', name: 'git', useDefaultExcludes: false // .git is excluded by default
        }
    }
}

stage('build and test') {
    nodeWithVersion(versionSuffix) {
        withJUnit {
            sh './gradlew -Pdist=addongradleplugin clean build test install -x javadoc' + defaultGradleArgs
        }

        withX {
            withJUnit {
                // TODO: replace with publishdists
                sh './gradlew -Pdist=minimal clean build test -x javadoc' + defaultGradleArgs
            }
        }

        stash name: 'compiled'
    }
}

if (deployDists) {
    parallel (
        'create distributions': {
            stage('createDists') {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    withX {
                        withJUnit {
                            // TODO: replace with publishdists
                            sh './gradlew -Pdist=minimal distZips' + defaultGradleArgs
                        }
                    }
                    stash name: 'dists', includes: 'build/distributions/**'
                }
            }

            stage('checkDists') {
                // TODO: add dists
//                def dists = ['minimal', 'standard', 'pro', 'android', 'relaystandalone']
                def dists = ['minimal']
                def checkDists = [:];

                for (int i = 0; i < dists.size(); i++) {
                    def distName = dists[i];
                    checkDists["checkdist${distName}"] = {
                        nodeWithVersion(versionSuffix) {
                            deleteDir()
                            unstash 'dists'
                            dir('build/distributions') {
                                sh "mv */jadex-${distName}-*.zip ./"
                                sh 'rm -r sources'
                                compareDist(distName)
                            }
                        }
                    }
                }
                parallel checkDists
            }
        },

        'docs': {
            stage ('docs') {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'sources'
                    sh './gradlew -b docs/mkdocs-ng/build.gradle clean buildDocsZip buildDocsPdf'
                    sh './gradlew -Pdist=addonjavadoc clean javadocZip'
                    stash name: 'docs', includes: 'docs/mkdocs-ng/build/*.zip, docs/mkdocs-ng/build/*.pdf, build/distributions/*.zip'
                }
            }
        },
    )
} else {
    echo "nothing to do, deployDists is disabled"
}

stage ('publish and deploy') {
    parallel (
        'publish and tag': {
            if (publishArtifacts) {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    // testing already done
                    // TODO: replace with publishdists
                    def cmd = './gradlew -Pdist=minimal build -x test uploadArchives '
                    if (publishToDummy) {
                        cmd += '-P repo_noncommercial=https://nexus.actoron.com/content/repositories/dummy/ -P repo_commercial= '
                    }
                    if (!publishCommercial) {
                        cmd += '-P repo_commercial= '
                    }
                    cmd += defaultGradleArgs
                    sh cmd
//                    print "On branch: ${env.BRANCH_NAME}"
                }

                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'git'
                    if (!publishToDummy) {
                        sh "git tag -a ${jadexVersion} -m \"build version ${jadexVersion}\""
                        sh "git push origin ${jadexVersion}"
                    } else {
                        println "not tagging as this is only dummy publishing"
                    }
                }
            }
        },

        'deploy': {
            if (deployDists) {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    // gather artifacts:
                    unstash 'docs'

                    sh 'mkdir -p deployment/docs'

                    sh 'mv docs/mkdocs-ng/build/*.zip docs/mkdocs-ng/build/*.pdf deployment/docs/'
                    sh 'mv build/distributions/*.zip deployment/docs/'

                    unstash 'compiled'
                    sh 'mkdir deployment/schemadoc'
                    sh 'mv **/build/schemadocs/* deployment/schemadoc/'

                    sh 'mkdir deployment/schemas'
                    sh 'mv **/build/schemas/* deployment/schemas/'

                    sh 'mkdir deployment/distributions'
                    // TODO uncomment when publishdists is reactivated:
//                    sh 'mv build/distributions/commercial deployment/distributions/'
                    sh 'mv build/distributions/noncommercial deployment/distributions/'
                    sh 'mv build/distributions/exampleprojects deployment/distributions/'
                    sh 'mv build/*.properties deployment/'


                    // TODO uncomment when publishdists is reactivated:
//                    sh 'mkdir deployment/webapps'
//                    sh 'mv **/build/libs/*.war deployment/webapps/'
//                    dir('webapps') {
//                        sh 'mv jadex-applications-web-*.war jadex-applications-web.war'
//                        sh 'mv jadex-platform-extension-relay-web-*.war relay.war'
//                        sh 'mv jadex-servletfilter-web-*.war webapi.war'
//                    }
                    deleteDir()

                    unstash 'dists'

                    // todo deploy webapps over ssh

                    // create directories
                    sshDownloads """mkdir -p /www/tmp/oss/${jadexVersion}/exampleprojects/
                                    mkdir -p /www/tmp/pro/${jadexVersion}/
                                    mkdir -p /www/schemas/
                                    mkdir -p /www/docs/nightlies/jadex-${jadexVersion}"""

                    // deploy schemas to actoron downloads
                    copyDownloads 'deployment/schemas/*.*', '/www/schemas/'

                    // deploy mkdocs (html + pdf)
                    copyDownloads 'deployment/docs/*.zip', '/www/docs/nightlies/'
                    // todo extract and adjust links
//                    unzip -o /www/docs/nightlies/jadex-mkdocs-*.zip -d /www/docs/nightlies/jadex-${jadexversion}/
//                            rm /www/docs/nightlies/jadex-mkdocs-*.zip
//
//                    unzip -o /www/docs/nightlies/*-javadoc.zip -d /www/docs/nightlies/jadex-${jadexversion}/
//                      rm /www/docs/nightlies/*-javadoc.zip
//
//                      # adjust latest symlink
//                  ln -sfT "jadex-${jadexversion}" "/www/docs/nightlies/latest"

                    copyDownloads 'deployment/docs/*.pdf', "/www/docs/nightlies/jadex-${jadexVersion}"

                    // schemadoc
                    copyDownloads 'deployment/schemadoc/*.*', "/www/docs/nightlies/jadex-${jadexVersion}"

                    // deploy distributions + exampleprojects to download

                    // TODO uncomment when publishdists is reactivated:
                    //copyDownloads 'deployment/distributions/commercial/*.zip', "/www/tmp/pro/${jadexVersion}"
                    copyDownloads 'deployment/distributions/noncommercial/*.zip', "/www/tmp/oss/${jadexVersion}"
                    copyDownloads 'deployment/distributions/exampleprojects/*.zip', "/www/tmp/oss/${jadexVersion}/exampleprojects/"

                    // TODO move to correct location and adjust symlink
                    // distributions:

//                    TYPE="pro"
//                    TARGET="snapshots"
//
//                    # remove old snapshot with same date if exists
//                    if [ -d "/www/$TARGET/$TYPE/${jadexversion}" ]; then
//                    rm -r "/www/$TARGET/$TYPE/${jadexversion}"
//                    fi
//
//                    mv /www/tmp/$TYPE/${jadexversion} /www/$TARGET/$TYPE/
//
//                            echo "${jadexversion}" > /www/$TARGET/$TYPE/${jadexversion}/version.txt
//
//                    # adjust latest symlink
//                    ln -sfT "${jadexversion}" "/www/$TARGET/$TYPE/latest"
//
//                    # rm tmp dir
//                    rmdir /www/tmp/$TYPE
//                    rmdir --ignore-fail-on-non-empty /www/tmp

                    // exampleprojects:

                    // mv /www/tmp/oss/${jadexversion}/exampleprojects/*.zip /www/snapshots/oss/${jadexversion}/
                    //
                    //# rm tmp dir
                    //rmdir /www/tmp/oss/${jadexversion}/exampleprojects
                    //rmdir /www/tmp/oss/${jadexversion}
                    //rmdir /www/tmp/oss
                    //rmdir --ignore-fail-on-non-empty /www/tmp
                }
            }
        }
    )
}

if (performanceTests) {
    stage ('performancetests') {
        nodeWithVersion(versionSuffix) {
            deleteDir()
            unstash 'compiled'
            withJUnit {
                sh './gradlew performanceTest' + defaultGradleArgs
            }
        }
    }
}

// ------- Helper functions --------

@NonCPS // cannot serialize regex.Matcher
def getVersionsFromTag(gittag) {
    def groups = (gittag =~ /(\d+)\.(\d+).(\d+)(?:(\w*)-(\d+))?/)
    if (!groups.matches()) {
        throw new RuntimeException("Could not find version pattern in last git tag: " + gittag)
    }
    return [
            major: groups[0][1],
            minor: groups[0][2],
            patch: groups[0][3],
            branchName: groups[0][4],
            branchPatch: groups[0][5]
    ]
}

def withX(func) {
    wrap([$class: 'Xvnc', useXauthority: true]) {
        func()
    }
}

String[] runCmdAndSplit(command) {
    def stdout = sh (script: command, returnStdout: true).trim()
    return stdout.split("\n")
}

def nodeWithVersion(String label = '', version, cl) {
    node(label) {
        timeout(time:1, unit: 'HOURS') {
            withEnv(['BUILD_VERSION_SUFFIX=' + version]) {
                try {
                    cl()
                } catch (Exception e) {
                    println "Build Exception: ${e.getMessage()}"
                    throw e
                }
            }
        }
    }
}

def withJUnit(cl){
    try {
        cl()
    } catch (Exception e) {
        junit '**/test-results/*.xml'
        throw e
    }
}

def compareDist(String distribution) {
    //sh 'if [ -d "sources" ]; then rm -r "sources";fi'
    sh "unzip jadex-${distribution}*-sources.zip"
    // build new dist from sources
    dir ('sources') {
        sh "./gradlew -Pdist=${distribution} distZip -x test -x javadoc" + defaultGradleArgs
    }

    sh 'mkdir rebuild'
    sh 'mv sources/build/distributions/**/*.zip rebuild/'

    sh 'mkdir compare'

    //list zips:
    // list content of distzip (jars): file (no file size)

    String[] files = runCmdAndSplit("ls jadex-${distribution}*.zip")
    println "listing contents of dist: ${files}"

    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > 'compare/${it}.lst' "
    }

    // sources: length, crc32, name
    files = runCmdAndSplit("ls jadex-${distribution}*-sources.zip")
    println "listing contents of sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"$it\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > 'compare/${it}.lst' "
    }

    // rebuild dist
    files = runCmdAndSplit("ls rebuild/jadex-${distribution}*.zip")
    println "listing contents of rebuild dist: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // rebuild sources
    files = runCmdAndSplit("ls rebuild/jadex-${distribution}*-sources.zip")
    println "listing contents of rebuild sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"${it}\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // now compare
    files = runCmdAndSplit("ls compare/*.lst")
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        echo "checking for difference in ${it} ..."
        sh "diff -w '${it}' '${it}-rebuild' > '${it}'.diff || echo 'rebuild distribution differs from original: ${it.substring(0,it.length()-5)}'"
        // jenkins aborts here if there is a difference.
    }

}

def copyDownloads(src, dest) {
    sh "scp -i ~/.ssh/pushuser.key -P 20000 -r ${src} webpush@download.actoron.com:${dest}"
}

def sshDownloads(cmd) {
    sh """ssh -i ~/.ssh/pushuser.key -p 20000 webpush@download.actoron.com "${cmd}" """
}
