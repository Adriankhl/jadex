// params set from jenkins job:
//performanceTests = true;
//deployDists = true;
//publishArtifacts = true;
//branchToBuild = "master";

defaultGradleArgs = " --info --stacktrace"


def branchName
//@Field
//String genVersion

import groovy.transform.Field

@Field
String jadexVersion

@Field
String major
@Field
String minor
@Field
String patch

def versionSuffix

stage('preparation') {
    node { // a node is a step with workspace, can be distributed
        git url: 'ssh://jenkins@repo.actoron.com:20000/repositories/jadex', branch: branchToBuild
        echo "testing jenkins with pipeline"

        branchName = sh (script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()
//        println "On branch: ${env.BRANCH_NAME}" // for multibranch projects, this works?
        println "On branch: ${branchName}"

        // parse last git tag
        def git_tag = sh(returnStdout: true, script: 'git describe --abbrev=0 --tags').trim()
        println git_tag

        def groups = (git_tag =~ /(\d+)\.(\d+).(\d+)(?:(\w*)-(\d+))?/)

        if (!groups.matches()) {
            throw new RuntimeException("Could not find version pattern in last git tag: " + git_tag)
        }

        major = groups[0][1]
        minor = groups[0][2]
        patch = groups[0][3]

        if ("master".equals(branchName)) {
            // generate version continuously
            //def result = build job: "pipeline-generate-version-${branchName}"
            // needs whitelisting, see https://issues.jenkins-ci.org/browse/JENKINS-36528
            //genVersion = result.rawBuild.environment.PATCH_VERSION;

            currentBuild.description = "build in master branch"
            // increase patch leve
            patch = patch as Integer
            patch++
            versionSuffix = "${patch}"

            // TODO: handle problem where last master tag is a tag from a branch (is that even a problem?)
        } else {
            currentBuild.description = "build in branch: ${branchName}"
            def branchBuildVersion
            if (groups[0][4]) {
                if (groups[0][4].equals(branchName)) {
                    throw new RuntimeException("Something went wrong, expected last tag to be for branch: ${branchName}, but got tag: ${git_tag}")
                }
                branchBuildVersion = groups[0][5] as Integer;
                branchBuildVersion++
            } else {
                // no branch build yet
                branchBuildVersion = 1
            }
            versionSuffix = "${patch}${branchName}-${branchBuildVersion}"
            // so we append something to our version. but what?
            //versionSuffix = "${result.rawBuild.environment.PATCH_VERSION}${branchName}"
        }

        echo "version suffix:" + versionSuffix
        // TODO: stash?
    }

    nodeWithVersion(versionSuffix) {
        // TODO: unstash?
        sh "./gradlew createVersionInfo"
        def props = readProperties file: 'build/jadexversion.properties'
        jadexVersion = props.jadexversion
        major = props.jadexVersion_major
        minor = props.jadexVersion_minor
        patch = props.jadexVersion_patch

        println "building version: ${jadexVersion}"
        currentBuild.displayName = "${jadexVersion}"

        sh './gradlew gendeplist'
        stash name: 'sources'
        stash includes: '.git/**', name: 'git', useDefaultExcludes: false // .git is excluded by default
    }
}

stage('build and test') {
    nodeWithVersion(versionSuffix) {
        withJUnit {
            sh './gradlew -Pdist=addongradleplugin clean build test install -x javadoc' + defaultGradleArgs
        }

        withX {
            withJUnit {
                sh './gradlew -Pdist=publishdists clean build test -x javadoc' + defaultGradleArgs
            }
        }

        stash name: 'compiled'
    }
}

if (deployDists) {
    parallel (
        'create distributions': {
            stage('createDists') {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    withX {
                        withJUnit {
                            sh './gradlew -Pdist=publishdists distZips' + defaultGradleArgs
                        }
                    }
                    stash name: 'dists', includes: 'build/distributions/**'
                }
            }

            stage('checkDists') {
                def dists = ['minimal', 'standard', 'pro', 'android', 'relaystandalone']
                def checkDists = [:];

                for (int i = 0; i < dists.size(); i++) {
                    def distName = dists[i];
                    checkDists["checkdist${distName}"] = {
                        nodeWithVersion(versionSuffix) {
                            deleteDir()
                            unstash 'dists'
                            dir('build/distributions') {
                                sh "mv */jadex-${distName}-*.zip ./"
                                sh 'rm -r sources'
                                compareDist(distName)
                            }
                        }
                    }
                }
                parallel checkDists
            }
        },

        'docs': {
            stage ('docs') {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'sources'
                    sh './gradlew -b docs/mkdocs-ng/build.gradle clean buildDocsZip buildDocsPdf'
                    sh './gradlew -Pdist=addonjavadoc clean javadocZip'
                    stash name: 'docs', includes: 'docs/mkdocs-ng/build/*.zip, docs/mkdocs-ng/build/*.pdf, build/distributions/*.zip'
                }
            }
        },
    )
} else {
    echo "nothing to do, deployDists is disabled"
}

stage ('publish and deploy') {
    parallel (
        'publish and tag': {
            if (publishArtifacts) {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    // testing already done
                    sh './gradlew -P repo_noncommercial=https://nexus.actoron.com/content/repositories/dummy/ -P repo_commercial= -Pdist=publishdists build -x test uploadArchives ' + defaultGradleArgs
//                    print "On branch: ${env.BRANCH_NAME}"
                }
            }

            nodeWithVersion(versionSuffix) {
                deleteDir()
                unstash 'git'
                sh "git tag -a ${jadexVersion} -m \"build version ${jadexVersion}\""
                //        sh "git push ${jadexVersion}" // TODO uncomment for push tag
            }
        },

        'deploy': {
            if (deployDists) {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    // gather artifacts:
                    unstash 'docs'
                    sh 'mv docs/mkdocs-ng/build/*.zip docs/mkdocs-ng/build/*.pdf docs/'
                    sh 'mv build/distributions/*.zip docs/'

                    unstash 'compiled'
                    sh 'mkdir schemadoc'
                    sh 'mv **/build/schemadocs/* schemadoc/'

                    sh 'mkdir schemas'
                    sh 'mv **/build/schemas/* schemas/'

                    sh 'mkdir webapps'
                    sh 'mv **/build/libs/*.war webapps/'
                    dir('webapps') {
                        sh 'mv jadex-applications-web-*.war jadex-applications-web.war'
                        sh 'mv jadex-platform-extension-relay-web-*.war relay.war'
                        sh 'mv jadex-servletfilter-web-*.war webapi.war'
                    }

                    unstash 'dists'

                    // todo deploy webapps over ssh
                    // todo deploy schemas to actoron downloads
                    // todo deploy mkdocs (html + pdf)
                    // todo schemadoc
                    // todo deploy distributions + exampleprojects to download

                }
            }
        }
    )
}

if (performanceTests) {
    stage ('performancetests') {
        nodeWithVersion(versionSuffix) {
            deleteDir()
            unstash 'compiled'
            withJUnit {
                sh './gradlew performanceTest' + defaultGradleArgs
            }
        }
    }
}

// ------- Helper functions --------

def withX(func) {
    wrap([$class: 'Xvnc', useXauthority: true]) {
        func()
    }
}

String[] runCmdAndSplit(command) {
    def stdout = sh (script: command, returnStdout: true).trim()
    return stdout.split("\n")
}

def nodeWithVersion(String label = '', version, cl) {
    node(label) {
        tryOrRevertVersion(version) {
            withEnv(['BUILD_VERSION_SUFFIX='+version]) {
                cl()
            }
        }
    }
}

def withJUnit(cl){
    try {
        cl()
    } catch (Exception e) {
        junit '**/test-results/*.xml'
        throw e
    }
}

def tryOrRevertVersion(version, cl) {
    try {
        cl()
    } catch (Exception e) {
        println "Build Exception: ${e.getMessage()}"
//        revertVersion()
        throw e
    }
}

@Field
Boolean revertedVersion = false

def revertVersion() {
//    if (!revertedVersion) {
//        Integer oldNumber = (genVersion as Integer) -1;
//        echo "reverting version from ${genVersion} to ${oldNumber}"
//        def result = build job: 'pipeline-generate-version-master', parameters: [string(name: 'PATCH_VERSION', value: "${oldNumber}")], wait: true, propagate: true
//
//        // needs whitelisting, see https://issues.jenkins-ci.org/browse/JENKINS-36528
//        def generatedOldNumber = result.rawBuild.environment.PATCH_VERSION;
//
//        echo "reverted version to: ${generatedOldNumber}"
//
//        revertedVersion = true
//    }
}

def compareDist(String distribution) {
    //sh 'if [ -d "sources" ]; then rm -r "sources";fi'
    sh "unzip jadex-${distribution}*-sources.zip"
    // build new dist from sources
    dir ('sources') {
        sh "./gradlew -Pdist=${distribution} distZip -x test -x javadoc" + defaultGradleArgs
    }

    sh 'mkdir rebuild'
    sh 'mv sources/build/distributions/**/*.zip rebuild/'

    sh 'mkdir compare'

    //list zips:
    // list content of distzip (jars): file (no file size)

    String[] files = runCmdAndSplit("ls jadex-${distribution}*.zip")
    println "listing contents of dist: ${files}"

    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > 'compare/${it}.lst' "
    }

    // sources: length, crc32, name
    files = runCmdAndSplit("ls jadex-${distribution}*-sources.zip")
    println "listing contents of sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"$it\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > 'compare/${it}.lst' "
    }

    // rebuild dist
    files = runCmdAndSplit("ls rebuild/jadex-${distribution}*.zip")
    println "listing contents of rebuild dist: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // rebuild sources
    files = runCmdAndSplit("ls rebuild/jadex-${distribution}*-sources.zip")
    println "listing contents of rebuild sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"${it}\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // now compare
    files = runCmdAndSplit("ls compare/*.lst")
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        echo "checking for difference in ${it} ..."
        sh "diff -w '${it}' '${it}-rebuild' > '${it}'.diff || echo 'rebuild distribution differs from original: ${it.substring(0,it.length()-5)}'"
        // jenkins aborts here if there is a difference.
    }

}

