// params set from jenkins job:
//performanceTests = true;
//deployDists = true;
//publishArtifacts = true;
//branchToBuild = "master";

//publishToDummy = true
// publishCommercial = true;

defaultGradleArgs = " --info --stacktrace --no-daemon"


def branchName

import groovy.transform.Field

@Field
String jadexVersion

@Field
Boolean isMasterBranch

@Field
Boolean isStableBranch

@Field
Boolean isTagRebuild

def versionSuffix

def lastVersionTag

util = ""

// convert parameters to booleans:
performanceTests = performanceTests.toBoolean()
publishArtifacts = publishArtifacts.toBoolean()
deployDists = deployDists.toBoolean()
publishToDummy = publishToDummy.toBoolean()
publishCommercial = publishCommercial.toBoolean()
tagBuild = tagBuild.toBoolean()
resetPatchVersion = resetPatchVersion.toBoolean()

node {
try {

stage('preparation') {
    node { // a node is a step with workspace, can be distributed
        try {
            println """Build params:
                branchToBuild: ${branchToBuild},
                tagToBuild: ${tagToBuild},
                performanceTests: ${performanceTests}, 
                publishArtifacts: ${publishArtifacts}, 
                publishToDummy: ${publishToDummy}, 
                publishCommercial: ${publishCommercial},
                tagBuild: ${tagBuild},
                deployDists: ${deployDists},
                resetPatchVersion: ${resetPatchVersion}"""

            util = fileLoader.fromGit('src/main/buildutils/JenkinsfileUtil.groovy',
                    'ssh://git@git.actoron.com:20000/jadex/jadex.git', 'jenkinsfile', null, '')

            if (tagToBuild && !tagToBuild.isEmpty()) {
                isTagRebuild = true
                echo "building from tag: " + tagToBuild
                echo "disabling tagging"
                tagBuild = false;
//               git url: 'ssh://git@git.actoron.com:20000/jadex/jadex.git', branch: "refs/tags/${tagToBuild}"
		checkout([$class: 'GitSCM', branches: [[name: "refs/tags/${tagToBuild}"]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], 
			userRemoteConfigs: 
			[[url: 'ssh://git@git.actoron.com:20000/jadex/jadex.git']]])
            } else {
                // build from branch
                git url: 'ssh://git@git.actoron.com:20000/jadex/jadex.git', branch: branchToBuild

                branchName = sh(script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()
                println "On branch: ${branchName}"
            }

            // parse last git tag
            def git_tag = sh(returnStdout: true, script: 'git describe --abbrev=0 --tags').trim()
            println "The tag used for generating a new version is: ${git_tag}"
            lastVersionTag = util.getVersionsFromTag(git_tag);
//            if (lastVersionTag == null) {
//            	error("Could not determine (last) version from tag: " + git_tag)
//            }
            def patch = lastVersionTag.patch

            // find tag name of HEAD:
            String git_headTag = sh(returnStdout: true, script: 'git tag --points-at HEAD').trim()
            println "The HEAD is tagged with: " + git_headTag


            if (isTagRebuild) {
                currentBuild.description = "rebuild of tag: ${git_tag}"
                if (lastVersionTag.branchName != null) {
                    versionSuffix = "${patch}${lastVersionTag.branchName}-${lastVersionTag.branchPatch}"
                } else {
                    versionSuffix = "${patch}"
                }
            } else {
                boolean headIsLastVersionTag = false
                def tags = util.runCmdAndSplit('git tag --points-at HEAD')
                for (int i = 0; i < tags.length; i++) {
                    if (git_tag.equals(tags[i])) {
                        headIsLastVersionTag = true
                        println "The last tag that was found on this branch points at HEAD, so nothing new happened since then."
                        timeout(time: 1, unit: 'HOURS') {
                            input(id: 'noNewCommits', message: 'Do you want to proceed anyway? This may lead in publish and/or tag pushing errors!')
                        }
                    }
                }

                currentBuild.description = "build in branch: ${branchName}"
                isMasterBranch = "master".equals(branchName)
                isStableBranch = "stable".equals(branchName)

                if (isMasterBranch || isStableBranch) {
                    // generate version continuously
                    patch = patch as Integer
                    if (resetPatchVersion) {
                        patch = 0;
                    } else if (!headIsLastVersionTag) {
                        // increase patch level if at least one commit is between last tag and HEAD
                        patch++
                    }
                    versionSuffix = "${patch}"

                } else {
                    // building some other branch
                    Integer branchPatch
                    if (lastVersionTag.branchName) {
                        if (!lastVersionTag.branchName.equals(branchName)) {
                            error("Something went wrong, expected last tag to be for branch: ${branchName}, but got tag: ${git_tag}")
                        }
                        branchPatch = lastVersionTag.branchPatch as Integer;
                        if (!headIsLastVersionTag) {
                            // increase patch level if at least one commit is between last tag and HEAD
                            branchPatch++
                        }
                    } else {
                        // no branch build yet
                        branchPatch = 1
                    }
                    versionSuffix = "${patch}${branchName}-${branchPatch}"
                    // so we append something to our version. but what?
                    //versionSuffix = "${result.rawBuild.environment.PATCH_VERSION}${branchName}"
                }

            }
            echo "Version suffix:" + versionSuffix

            withEnv(['BUILD_VERSION_SUFFIX=' + versionSuffix]) {
                sh './gradlew createVersionInfo' + defaultGradleArgs
                def props = readProperties file: 'build/jadexversion.properties'
                jadexVersion = props.jadexversion

                // check plausibility of version:
                if ((lastVersionTag.major != props.jadexversion_major
                     || lastVersionTag.minor != props.jadexversion_minor) && !resetPatchVersion) {
                    println "The major or minor version seems to have changed and resetPatchVersion is not set." +
                            "old major/minor: ${lastVersionTag.major}.${lastVersionTag.minor}" +
                            "new major/minor: ${props.jadexversion_major}.${props.jadexversion_minor}"
                    timeout(time: 1, unit: 'HOURS') {
                        input(id: 'noNewCommits', message: 'Do you want to proceed anyway? When dumping the version, you should build with resetPatchVersion=true!')
                    }
                }

                println "building version: ${jadexVersion}"
                currentBuild.displayName = "${jadexVersion}"

                stash name: 'sources'
                stash includes: '.git/**', name: 'git', useDefaultExcludes: false
                // .git is excluded by default
            }
        } catch (any) {
            currentBuild.result = 'FAILURE'
            throw any;
        } finally {
            step([$class: 'Mailer', notifyEveryUnstableBuild: true, recipients: 'kalinowski@informatik.uni-hamburg.de', sendToIndividuals: true])
        }
    }
}

stage('build and test') {
    util.nodeWithVersion(versionSuffix) {
        util.withJUnit {
            sh './gradlew -Pdist=addongradleplugin clean build test install -x javadoc' + defaultGradleArgs
        }

        util.withX {
            util.withJUnit {
                sh './gradlew -Pdist=publishdists clean build test -x javadoc' + defaultGradleArgs
            }
        }

        stash name: 'compiled'
    }
}

if (deployDists) {
    parallel (
        'create distributions': {
            stage('createDists') {
                util.nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    util.withX {
//                        util.withJUnit {
                            sh './gradlew -Pdist=publishdists distZips -x test' + defaultGradleArgs
//                        }
                    }
                    stash name: 'dists', includes: 'build/distributions/**, build/*.properties'
                }
            }

            stage('checkDists') {
                def dists = ['minimal', 'standard', 'pro', 'android']
//                def dists = ['minimal']
                def checkDists = [:];

                for (int i = 0; i < dists.size(); i++) {
                    def distName = dists[i];
                    checkDists["checkdist${distName}"] = {
                        util.nodeWithVersion(versionSuffix) {
                            deleteDir()
                            unstash 'dists'
                            dir('build/distributions') {
                                sh "mv */jadex-${distName}-*.zip ./"
                                sh 'rm -r sources'
                                compareDist(distName)
                            }
                        }
                    }
                }
                parallel checkDists
            }
        },

        'docs': {
            stage ('docs') {
                util.nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'sources'
                    sh './gradlew -b docs/mkdocs-ng/build.gradle clean buildDocsZip buildDocsPdf' + defaultGradleArgs
                    sh './gradlew -Pdist=addonjavadoc clean javadocZip' + defaultGradleArgs
                    stash name: 'docs', includes: 'docs/mkdocs-ng/build/*.zip, docs/mkdocs-ng/build/*.pdf, build/distributions/*.zip'
                }
            }
        },
    )
} else {
    echo "nothing to do, deployDists is disabled"
}

stage ('publish and deploy') {
    parallel (
        'publish and tag': {
            if (publishArtifacts) {
                util.nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    // testing already done
                    def cmd = './gradlew -Pdist=publishdists build -x test uploadArchives '
                    if (publishToDummy) {
                        cmd += '-P repo_noncommercial=https://nexus.actoron.com/content/repositories/dummy/ -P repo_commercial= '
                    }
                    if (!publishCommercial) {
                        cmd += '-P repo_commercial= '
                    }
                    cmd += defaultGradleArgs
                    sh cmd
//                    print "On branch: ${env.BRANCH_NAME}"
                }

                util.nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'git'
                    if (tagBuild && !publishToDummy) {
                        sh "git tag -a ${jadexVersion} -m \"build version ${jadexVersion}\""
                        sh "git push origin ${jadexVersion}"
                    } else {
                        if (publishToDummy) {
                            println "not tagging as this is only dummy publishing"
                        } else {
                            println "not tagging build"
                        }
                    }
                }
            }
        },

        'deploy': {
            if (deployDists) {
                util.nodeWithVersion(versionSuffix) {
                    deleteDir()
                    // gather artifacts:
                    unstash 'docs'

                    sh 'mkdir -p deployment/docs'

                    sh 'mv docs/mkdocs-ng/build/*.zip docs/mkdocs-ng/build/*.pdf deployment/docs/'
                    sh 'mv build/distributions/*.zip deployment/docs/'

                    unstash 'compiled'
                    sh 'mkdir deployment/schemadoc'
                    sh 'mv **/build/schemadocs/* deployment/schemadoc/'

                    sh 'mkdir deployment/schemas'
                    sh 'mv **/build/schemas/* deployment/schemas/'

                    sh 'mkdir deployment/webapps'
                    sh 'mv **/build/libs/*.war deployment/webapps/'
                    dir('deployment/webapps') {
                        sh 'mv jadex-applications-web-*.war jadex-applications-web.war'
                        //sh 'mv jadex-platform-extension-relay-web-*.war relay.war'
                        sh 'mv jadex-servletfilter-web-*.war webapi.war'
                    }

                    unstash 'dists'

                    sh 'mkdir deployment/distributions'
                    sh 'mv build/distributions/commercial deployment/distributions/'
                    sh 'mv build/distributions/noncommercial deployment/distributions/'
                    sh 'mv build/distributions/exampleprojects deployment/distributions/'
                    sh 'mv build/*.properties deployment/' // TODO needed?

                    // todo deploy webapps over ssh

                    // create directories
                    util.sshDownloads """mkdir -p /www/tmp/oss/${jadexVersion}/ &&
                                    mkdir -p /www/tmp/pro/${jadexVersion}/ &&
                                    mkdir -p /www/tmp/docs/ &&
                                    mkdir -p /www/schemas/ &&
                                    mkdir -p /www/docs/nightlies/jadex-${jadexVersion}"""

                    // deploy schemas to actoron downloads
                    util.copyDownloads 'deployment/schemas/*.*', '/www/schemas/'

                    // deploy mkdocs (html + pdf)
                    util.copyDownloads 'deployment/docs/*.zip', '/www/tmp/docs/'

                    util.sshDownloads """unzip -o /www/tmp/docs/jadex-mkdocs-*.zip -d /www/docs/nightlies/jadex-${jadexVersion}/ &&
                                    rm /www/tmp/docs/jadex-mkdocs-*.zip &&
                                    unzip -o /www/tmp/docs/*-javadoc.zip -d /www/docs/nightlies/jadex-${jadexVersion}/ &&
                                    rm /www/tmp/docs/*-javadoc.zip &&
                                    rmdir /www/tmp/docs"""

                    if (isMasterBranch) {
                        // adjust latest symlink
                        util.sshDownloads """ln -sfT "jadex-${jadexVersion}" "/www/docs/nightlies/latest" """
                    }

                    util.copyDownloads 'deployment/docs/*.pdf', "/www/docs/nightlies/jadex-${jadexVersion}"

                    // schemadoc
                    util.copyDownloads 'deployment/schemadoc', "/www/docs/nightlies/jadex-${jadexVersion}/"

                    // deploy distributions

                    util.copyDownloads 'deployment/distributions/commercial/*.zip', "/www/tmp/pro/${jadexVersion}"
                    util.copyDownloads 'deployment/distributions/noncommercial/*.zip', "/www/tmp/oss/${jadexVersion}"

                    // distributions:

                    def TARGET = 'snapshots'
                    for (TYPE in ['oss', 'pro']) {
                        util.sshDownloads """# remove old snapshot with same version if exists
                                        if [ -d "/www/$TARGET/$TYPE/${jadexVersion}" ]; then
                                            rm -r "/www/$TARGET/$TYPE/${jadexVersion}"
                                        fi
                    
                                        mv /www/tmp/$TYPE/${jadexVersion} /www/$TARGET/$TYPE/ &&
                                        echo "${jadexVersion}" > /www/$TARGET/$TYPE/${jadexVersion}/version.txt &&
                    
                                        # rm tmp dir
                                        rmdir /www/tmp/$TYPE &&
                                        rmdir --ignore-fail-on-non-empty /www/tmp"""
                        if (isMasterBranch) {
                            // adjust latest symlink
                            util.sshDownloads """ln -sfT "${jadexVersion}" "/www/$TARGET/$TYPE/latest" """
                        }
                    }

                    // exampleprojects:
                    //util.sshDownloads "mkdir -p /www/snapshots/oss/${jadexVersion}/exampleprojects"
                    util.copyDownloads 'deployment/distributions/exampleprojects/*.zip', "/www/snapshots/oss/${jadexVersion}/"
                }
            }
        }
    )
}

if (performanceTests) {
    stage ('performancetests') {
        util.nodeWithVersion(versionSuffix) {
            deleteDir()
            unstash 'compiled'
            util.withJUnit {
                sh './gradlew performanceTest' + defaultGradleArgs
            }
        }
    }
}

} catch (any) {
    currentBuild.result = 'FAILURE'
    throw any;
} finally {
    step([$class: 'Mailer', notifyEveryUnstableBuild: true, recipients: 'kalinowski@informatik.uni-hamburg.de', sendToIndividuals: true])
}
}


def compareDist(String distribution) {
    //sh 'if [ -d "sources" ]; then rm -r "sources";fi'
    sh "unzip jadex-${distribution}*-sources.zip"
    // build new dist from sources
    dir ('sources') {
        sh "./gradlew -Pdist=${distribution} distZip -x test -x javadoc" + defaultGradleArgs
    }

    sh 'mkdir rebuild'
    sh 'mv sources/build/distributions/**/*.zip rebuild/'

    sh 'mkdir compare'

    //list zips:
    // list content of distzip (jars): file (no file size)

    String[] files = util.runCmdAndSplit("ls jadex-${distribution}*.zip")
    println "listing contents of dist: ${files}"

    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > 'compare/${it}.lst' "
    }

    // sources: length, crc32, name
    files = util.runCmdAndSplit("ls jadex-${distribution}*-sources.zip")
    println "listing contents of sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"$it\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > 'compare/${it}.lst' "
    }

    // rebuild dist
    files = util.runCmdAndSplit("ls rebuild/jadex-${distribution}*.zip")
    println "listing contents of rebuild dist: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // rebuild sources
    files = util.runCmdAndSplit("ls rebuild/jadex-${distribution}*-sources.zip")
    println "listing contents of rebuild sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"${it}\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // now compare
    files = util.runCmdAndSplit("ls compare/*.lst")
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        echo "checking for difference in ${it} ..."
        sh "diff -w '${it}' '${it}-rebuild' > '${it}'.diff || echo 'rebuild distribution differs from original: ${it.substring(0,it.length()-5)}'"
        // jenkins aborts here if there is a difference.
    }
}

