// params set from jenkins job:
//performanceTests = true;
//deployDists = true;
//publishArtifacts = true;
//branchToBuild = "master";

//publishToDummy = true
// publishCommercial = true;

defaultGradleArgs = " --info --stacktrace"


def branchName

import groovy.transform.Field

@Field
String jadexVersion

def versionSuffix

// convert parameters to booleans:
performanceTests = performanceTests.toBoolean()
publishArtifacts = publishArtifacts.toBoolean()
deployDists = deployDists.toBoolean()
publishToDummy = publishToDummy.toBoolean()
publishCommercial = publishCommercial.toBoolean()

stage('preparation') {
    node { // a node is a step with workspace, can be distributed

        println """Build params: 
                branchToBuild: ${branchToBuild}, 
                performanceTests: ${performanceTests}, 
                publishArtifacts: ${publishArtifacts}, 
                publishToDummy: ${publishToDummy}, 
                publishCommercial: ${publishCommercial},
                deployDists: ${deployDists}"""

        git url: 'ssh://jenkins@repo.actoron.com:20000/repositories/jadex', branch: branchToBuild
        echo "testing jenkins with pipeline"

        branchName = sh(script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()
//        println "On branch: ${env.BRANCH_NAME}" // for multibranch projects, this works?
        println "On branch: ${branchName}"

        // parse last git tag
        def git_tag = sh(returnStdout: true, script: 'git describe --abbrev=0 --tags').trim()
        println "The tag used for generating a new version is: ${git_tag}"

        // current git tag:
//        git describe --abbrev=0 --tags --exact-match

        // find tag name of HEAD:

        String git_headTag = sh(returnStdout: true, script: 'git tag --points-at HEAD').trim()
        println git_headTag

        boolean headIsLastVersionTag = false
        def tags = runCmdAndSplit('git tag --points-at HEAD')
        for (int i = 0; i < tags.length; i++) {
            if (git_tag.equals(tags[i])) {
                headIsLastVersionTag = true
                println "The last tag that was found on this branch points at HEAD, so nothing new happened since then."
                println "We will assume no new version number is needed, using the old one again..."
            }
        }

        def versionsFromTag = getVersionsFromTag(git_tag);
        def patch = versionsFromTag.patch

        currentBuild.description = "build in branch: ${branchName}"

        if ("master".equals(branchName)) {
            // generate version continuously
            //def result = build job: "pipeline-generate-version-${branchName}"
            // needs whitelisting, see https://issues.jenkins-ci.org/browse/JENKINS-36528
            //genVersion = result.rawBuild.environment.PATCH_VERSION;

            patch = patch as Integer
            if (!headIsLastVersionTag) {
                // increase patch level if at least one commit is between last tag and HEAD
                patch++
            }
            versionSuffix = "${patch}"

            // TODO: handle problem where last master tag is a tag from a branch (is that even a problem?)
        } else {
            Integer branchPatch
            if (versionsFromTag.branchName) {
                if (versionsFromTag.branchName.equals(branchName)) {
                    throw new RuntimeException("Something went wrong, expected last tag to be for branch: ${branchName}, but got tag: ${git_tag}")
                }
                branchPatch = versionsFromTag.branchPatch as Integer;
                if (!headIsLastVersionTag) {
                    // increase patch level if at least one commit is between last tag and HEAD
                    branchPatch++
                }
            } else {
                // no branch build yet
                branchPatch = 1
            }
            versionSuffix = "${patch}${branchName}-${branchPatch}"
            // so we append something to our version. but what?
            //versionSuffix = "${result.rawBuild.environment.PATCH_VERSION}${branchName}"
        }

        echo "version suffix:" + versionSuffix

        withEnv(['BUILD_VERSION_SUFFIX=' + versionSuffix]) {
            sh "./gradlew createVersionInfo"
            def props = readProperties file: 'build/jadexversion.properties'
            jadexVersion = props.jadexversion

            println "building version: ${jadexVersion}"
            currentBuild.displayName = "${jadexVersion}"

            sh './gradlew gendeplist'

            stash name: 'sources'
            stash includes: '.git/**', name: 'git', useDefaultExcludes: false // .git is excluded by default
        }
    }
}

stage('build and test') {
    nodeWithVersion(versionSuffix) {
        withJUnit {
            sh './gradlew -Pdist=addongradleplugin clean build test install -x javadoc' + defaultGradleArgs
        }

        withX {
            withJUnit {
                sh './gradlew -Pdist=publishdists clean build test -x javadoc' + defaultGradleArgs
            }
        }

        stash name: 'compiled'
    }
}

if (deployDists) {
    parallel (
        'create distributions': {
            stage('createDists') {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    withX {
                        withJUnit {
                            sh './gradlew -Pdist=publishdists distZips' + defaultGradleArgs
                        }
                    }
                    stash name: 'dists', includes: 'build/distributions/**'
                }
            }

            stage('checkDists') {
                def dists = ['minimal', 'standard', 'pro', 'android', 'relaystandalone']
                def checkDists = [:];

                for (int i = 0; i < dists.size(); i++) {
                    def distName = dists[i];
                    checkDists["checkdist${distName}"] = {
                        nodeWithVersion(versionSuffix) {
                            deleteDir()
                            unstash 'dists'
                            dir('build/distributions') {
                                sh "mv */jadex-${distName}-*.zip ./"
                                sh 'rm -r sources'
                                compareDist(distName)
                            }
                        }
                    }
                }
                parallel checkDists
            }
        },

        'docs': {
            stage ('docs') {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'sources'
                    sh './gradlew -b docs/mkdocs-ng/build.gradle clean buildDocsZip buildDocsPdf'
                    sh './gradlew -Pdist=addonjavadoc clean javadocZip'
                    stash name: 'docs', includes: 'docs/mkdocs-ng/build/*.zip, docs/mkdocs-ng/build/*.pdf, build/distributions/*.zip'
                }
            }
        },
    )
} else {
    echo "nothing to do, deployDists is disabled"
}

stage ('publish and deploy') {
    parallel (
        'publish and tag': {
            if (publishArtifacts) {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'compiled'
                    // testing already done
                    def cmd = './gradlew -Pdist=publishdists build -x test uploadArchives '
                    if (publishToDummy) {
                        cmd += '-P repo_noncommercial=https://nexus.actoron.com/content/repositories/dummy/ -P repo_commercial= '
                    }
                    if (!publishCommercial) {
                        cmd += '-P repo_commercial= '
                    }
                    cmd += defaultGradleArgs
                    sh cmd
//                    print "On branch: ${env.BRANCH_NAME}"
                }

                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    unstash 'git'
                    sh "git tag -a ${jadexVersion} -m \"build version ${jadexVersion}\""
                    if (!publishToDummy) {
                        sh "git push origin ${jadexVersion}"
                    } else {
                        println "not pushing tag as this is only dummy publishing"
                    }
                }
            }
        },

        'deploy': {
            if (deployDists) {
                nodeWithVersion(versionSuffix) {
                    deleteDir()
                    // gather artifacts:
                    unstash 'docs'
                    sh 'mv docs/mkdocs-ng/build/*.zip docs/mkdocs-ng/build/*.pdf docs/'
                    sh 'mv build/distributions/*.zip docs/'

                    unstash 'compiled'
                    sh 'mkdir schemadoc'
                    sh 'mv **/build/schemadocs/* schemadoc/'

                    sh 'mkdir schemas'
                    sh 'mv **/build/schemas/* schemas/'

                    sh 'mkdir webapps'
                    sh 'mv **/build/libs/*.war webapps/'
                    dir('webapps') {
                        sh 'mv jadex-applications-web-*.war jadex-applications-web.war'
                        sh 'mv jadex-platform-extension-relay-web-*.war relay.war'
                        sh 'mv jadex-servletfilter-web-*.war webapi.war'
                    }

                    unstash 'dists'

                    // todo deploy webapps over ssh
                    // todo deploy schemas to actoron downloads
                    // todo deploy mkdocs (html + pdf)
                    // todo schemadoc
                    // todo deploy distributions + exampleprojects to download

                }
            }
        }
    )
}

if (performanceTests) {
    stage ('performancetests') {
        nodeWithVersion(versionSuffix) {
            deleteDir()
            unstash 'compiled'
            withJUnit {
                sh './gradlew performanceTest' + defaultGradleArgs
            }
        }
    }
}

// ------- Helper functions --------

@NonCPS // cannot serialize regex.Matcher
def getVersionsFromTag(gittag) {
    def groups = (gittag =~ /(\d+)\.(\d+).(\d+)(?:(\w*)-(\d+))?/)
    if (!groups.matches()) {
        throw new RuntimeException("Could not find version pattern in last git tag: " + gittag)
    }
    return [
            major: groups[0][1],
            minor: groups[0][2],
            patch: groups[0][3],
            branchName: groups[0][4],
            branchPatch: groups[0][5]
    ]
}

def withX(func) {
    wrap([$class: 'Xvnc', useXauthority: true]) {
        func()
    }
}

String[] runCmdAndSplit(command) {
    def stdout = sh (script: command, returnStdout: true).trim()
    return stdout.split("\n")
}

def nodeWithVersion(String label = '', version, cl) {
    node(label) {
        withEnv(['BUILD_VERSION_SUFFIX='+version]) {
            try {
                cl()
            } catch (Exception e) {
                println "Build Exception: ${e.getMessage()}"
                throw e
            }
        }
    }
}

def withJUnit(cl){
    try {
        cl()
    } catch (Exception e) {
        junit '**/test-results/*.xml'
        throw e
    }
}

def compareDist(String distribution) {
    //sh 'if [ -d "sources" ]; then rm -r "sources";fi'
    sh "unzip jadex-${distribution}*-sources.zip"
    // build new dist from sources
    dir ('sources') {
        sh "./gradlew -Pdist=${distribution} distZip -x test -x javadoc" + defaultGradleArgs
    }

    sh 'mkdir rebuild'
    sh 'mv sources/build/distributions/**/*.zip rebuild/'

    sh 'mkdir compare'

    //list zips:
    // list content of distzip (jars): file (no file size)

    String[] files = runCmdAndSplit("ls jadex-${distribution}*.zip")
    println "listing contents of dist: ${files}"

    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > 'compare/${it}.lst' "
    }

    // sources: length, crc32, name
    files = runCmdAndSplit("ls jadex-${distribution}*-sources.zip")
    println "listing contents of sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"$it\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > 'compare/${it}.lst' "
    }

    // rebuild dist
    files = runCmdAndSplit("ls rebuild/jadex-${distribution}*.zip")
    println "listing contents of rebuild dist: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -l \"${it}\" | sed '1d' | head -n -1 | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // rebuild sources
    files = runCmdAndSplit("ls rebuild/jadex-${distribution}*-sources.zip")
    println "listing contents of rebuild sources: ${files}"
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
            sh "unzip -lv \"${it}\" | sed '1d' | sed 's/\\s*\\([0-9]*\\).*[0-2][0-9]:[0-6][0-9]\\(.*\\)/\\1\\t\\2/' > \"compare/\$(basename ${it}).lst-rebuild\""
    }

    // now compare
    files = runCmdAndSplit("ls compare/*.lst")
    for (int i = 0; i < files.length; i++) {
        def it = files[i]
        echo "checking for difference in ${it} ..."
        sh "diff -w '${it}' '${it}-rebuild' > '${it}'.diff || echo 'rebuild distribution differs from original: ${it.substring(0,it.length()-5)}'"
        // jenkins aborts here if there is a difference.
    }

}

