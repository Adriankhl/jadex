<app></app>
	
<script type="text/javascript">
	// Add a format method for Date 
	Date.prototype.yyyymmdd = function(sep) {
		var mm = (this.getMonth() + 1).toString();
		var dd = this.getDate().toString();
		return [this.getFullYear(), (mm.length===2 ? '' : '0')+mm, (dd.length===2 ? '' : '0')+dd].join(sep? sep: '');
	};
	//var now = new Date();
	//alert(now.yyyymmdd()+" "+now.yyyymmdd('-'));
	
	Array.prototype.equals = function(a, b) {
		if (a === b) return true;
		if (a == null || b == null) return false;
		if (a.length != b.length) return false;
	
		for (var i = 0; i < a.length; ++i) {
	    	if (a[i] !== b[i]) return false;
	  	}
	  	return true;
	};
	
	// not using var to set a global variable
	PROMISE_DOME = Promise.resolve("Dummy response to keep the console quiet");
	
	// https://riot.js.org/api/
   	// Note: users of In-browser compilation will need to wrap calls to riot.mount in riot.compile in order to get returned tag instances.
   	// Without this, calls to riot.mount will return undefined.
	riot.compile(function() {
		var Store = function() {
			riot.observable(this);
			this.language = "en";
			this.switchLanguage = function() 
			{
				if(this.language=="en") {
 		    		this.language="de";
				} 
				else {
 		    		this.language="en";
				}
				this.trigger('language', this.language);  
				//console.log(this.language);
			};
		};
		riot.store = new Store();
		
		var cnt = 0;
		
		var langmixin = {
			//self: null,
			//lang: "en",
			messages: {
	    		en: {
	   				message: {
	   					home: "Home",
	   					privacy: "Privacy", 
	   					imprint: "Imprint",
	   					about: "About"
	    			}
	  			},
		    	de: {
					message: {
						home: "Home",
						privacy: "Datenschutz",
	   					imprint: "Impressum",
						about: "Ãœber"
					}
	  			}
			},
			init: function() {
				// var must not be omitted here. otherwise it will automatically create a global variable
				var self = this;
				//console.log("created: "+self.id);
				self.id = cnt++;
				//console.log("created: "+self.id);
				riot.store.on('language', function(l) {
					self.lang = l;
					//console.log("lang: "+l+" "+self.id);
					self.update();
				});
				self.lang = riot.store.language;
			},
			translate: function(text) {
				var msg = this.messages[this.lang];
				if(msg) 
				{
					var toks = text.split('.');
					var tmp = msg;
					for(i=0; tmp!=null && i<toks.length; i++) 
					{
						tmp = tmp[toks[i]];
					}
					//console.log("text: "+text+" "+tmp);
					return tmp;
				}
				else 
				{
					return null;
				}
			},
			$t: function(text) 
			{
				return this.translate(text);
			},
			getLanguage: function() 
			{
				return this.lang=='de'? 0: 1;
			},
			createErrorMessage: function(text, data) 
			{
				var txt = data!=null? data: "No further info";
				var msg = {type: "error", text: text+txt};
				riot.store.trigger('message', msg);
			},
			createInfoMessage: function(text) 
			{
				var msg = {type: "info", text: text};
				riot.store.trigger('message', msg);
			},
			clearMessage: function() 
			{
				riot.store.trigger('message', null);
			}
		};
		riot.mixin(langmixin);
		
		var jadexmixin = {
			getIntermediate: function(path, handler, error) 
			{
				var	func = function(resp)
				{
					if(resp.status!=202)	// ignore updatetimer commands
						handler(resp);

					var callid = resp.headers["x-jadex-callid"];
					if(callid!=null)
						axios.get(path, {headers: {'x-jadex-callid': callid}}, self.transform).then(func).catch(error); 
					return this.PROMISE_DONE;
				};
				axios.get(path, self.transform).then(func).catch(error);
			}
		};
		riot.mixin(jadexmixin);
		
		var loader = 
		{
			loaded: {},
		    getHead: function()
		    {
		    	return document.getElementsByTagName("head")[0];
		    },
		    loadStyle: function(i, files, callback)
	        {
        		var self = this;

        		if(i>=files.length)
	        	{
	        		callback();
	        	}
	        	else if(this.loaded[files[i]]!=null)
	        	{
	        		//console.log("already loaded css: "+files[i]);
	        		self.loadStyle(i+1, files, callback);
	        	}
	        	else
	        	{
	        		this.loaded[files[i]] = files[i];
	        		
	        		var link = document.createElement("link");
		            link.rel = "stylesheet";
		            link.type = "text/css";
		            link.href = files[i];
		            
		            link.onload = function ()
		            {
		            	//console.log('Loaded style: ' + files[i]);
		            	self.loadStyle(i+1, files, callback);
		            };
		            link.onerror = function ()
		            {
		                //console.log('Error loading style: ' + files[i]);
		                self.loadStyle(i+1, files, callback);
		            };
		            
		            //console.log('Loading style ' + files[i]);
		           	self.getHead().appendChild(link);
	        	}
	        },
	        loadScript: function(i, files, callback)
	        {
        		var self = this;

        		if(i>=files.length)
	        	{
	        		callback();
	        	}
	        	else if(this.loaded[files[i]]!=null)
	        	{
	        		//console.log("already loaded script: "+files[i]);
	        		self.loadScript(i+1, files, callback);
	        	}
	        	else
	        	{
	        		this.loaded[files[i]] = files[i];
	        		
		            var script = document.createElement('script');
		            script.type = 'text/javascript';
		            script.src = files[i];
		            
		            script.onload = function ()
		            {
		                //console.log('Loaded script: ' + files[i]);
		                self.loadScript(i+1, files, callback);
		            };
		            script.onerror = function ()
		            {
		                //console.log('Error loading script: ' + files[i]);
		                self.loadScript(i+1, files, callback);
		            };
		            
		            //console.log('Loading script ' + files[i]);
		            self.getHead().appendChild(script);
	        	}
	        },
	        loadFiles: function(cssfiles, jsfiles, callback)
	        {
	        	var self = this;
	        	
	        	// loads recursively
	            self.loadStyle(0, cssfiles, function()
	            {
	            	self.loadScript(0, jsfiles, callback);
	            });
	        },
	       
		};
		riot.mixin(loader);
		
    	riot.mount('*');
    	
    	var curpage = null;
    	var target = "div#content";
    	var routes = ["platforms", "platform", "about", "imprint", "privacy"];
    	riot.store.language = "en";
    	
    	// As subpaths are supplied by separate args, internally arguments are used
    	route(function changePath(path) 
    	{
    		path = path.toLowerCase();
    		var paths = [];
    		var params = null;
    		for(i=0; i<arguments.length; i++)
    		{
    			if(arguments[i].indexOf("=")!=-1)
    				params = arguments[i];
    			else
    				paths.push(arguments[i]);
    		}
    		//console.log(path);
    		if(path.length==0)
    			path="platforms";
    		if(routes.includes(path)) 
    		{ 
    			if(curpage)
					curpage.unmount(true);
    	        var tags = riot.mount(target, path, {paths: paths, params: params});
    	        curpage = tags[0];
    	        //console.log(tags);
    		}
    	});
    	
    	route.start(true);
    	
    	riot.store.switchLanguage();
	});
</script>
