import java.nio.file.Paths
import java.util.regex.Matcher

apply plugin: 'signing'
//apply plugin: 'java-library-distribution'
apply plugin: 'maven-publish' // publishToMavenLocal
apply plugin: 'maven' // use gradle install to install in local .m2 
//apply plugin: 'net.researchgate.release'
// gradle install -x test -i    for fast local install without tests (-x test i program args)

def date = new Date()
def timestamp = date.format('yyyyMMdd.HHmmss')

def maindistsuffix = ''
gradle.ext.selecteddists.each { dname ->
	maindistsuffix += '-' + dname
}
// ressource files that are filtered for variables
project.ext.filterfiles = '*.xml,*.xsd,*.bat,*.sh,*.txt,*.gradle'

project.ext.srcdir = 'src'

project.ext.subprojectmap  = new HashMap()
project.subprojects.each { sp ->
	addSubproject('', sp)
}

project.ext.jadex_build_version=jadex_build_version
project.ext.jadex_lastbuild_version=jadex_lastbuild_version
project.ext.timestamp=timestamp

buildscript 
{
    apply from: 'util.gradle'
 
    repositories
    {
        //mavenLocal()
        mavenCentral()
        //jcenter()
    }
    
    dependencies
    {
        classpath 'com.android.tools.build:gradle:1.3.0'
        //classpath 'net.researchgate:gradle-release:2.2.2'
    }
}

allprojects
{
    version = jadex_build_version // Set the project version property, otherwise install does not work
    group = 'net.sourceforge.jadex'

    repositories
    {
        mavenCentral()
        
        // public sonatype repository for jmonkey artifacts
		maven
		{
			name 'sonatype public'
			url 'https://oss.sonatype.org/content/groups/public/'
		}
    }
    
    buildscript 
	{
	    repositories
	    {
			mavenLocal()
	    	mavenCentral()
	        maven
			{
				url "http://www2.activecomponents.org/nexus/content/repositories/snapshots/"
			}
	    }
	}
	
	if (JavaVersion.current().isJava8Compatible()) {
		tasks.withType(Javadoc) {
        	options.addStringOption('Xdoclint:none', '-quiet')
        }
	}
}

subprojects
{
    def mainSrcDir  = 'src/main/java'
    def testSrcDir  = 'src/test/java'
    def junit       = 'junit:junit:4.11'
    def allSource   = ''
    
    ext.libraries = [
            android_support: "com.android.support:support-v4:23.1.0",
            android_compat: "com.android.support:appcompat-v7:23.1.0",
            android: 'com.google.android:android:2.2.1',
            android_test: "com.google.android:android-test:2.2.1",
            protobuf: "com.google.protobuf:protobuf-java:2.4.1",
            junit: junit,
            robotium: 'com.jayway.android.robotium:robotium-solo:3.3',
            robolectric: 'org.robolectric:robolectric:2.2'
    ]

    if(isAndroidProject(project))
    {
	 	if (isAndroidLibraryProject(project))
        {
            apply plugin: 'android-library'
        }
        else 
        {
            apply plugin: 'com.android.application'
        }

		// strip "-release" from .aar and .apks
		onReleaseOutput(project) {output ->
			def fileName = output.outputFile.getName()
			output.outputFile = new File(output.outputFile.parent, "$archivesBaseName-${version}${fileName.substring(fileName.lastIndexOf("."))}")
		}

    	android {
            compileSdkVersion android_compileSdkVersion
            buildToolsVersion android_buildToolsVersion

            defaultConfig {
                minSdkVersion android_minSdkVersion
                targetSdkVersion android_targetSdkVersion
                versionCode 1
                versionName project.version
            }

            sourceSets {
                main {
                    manifest.srcFile 'src/main/AndroidManifest.xml'
                    resources.srcDirs = ['src/main/java']
                    aidl.srcDirs = ['src/main/java']
                    res.srcDirs = ['src/main/res']
                }
            }

            buildTypes {
                release {
                    // runProguard true
                    // proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
                }
            }

            packagingOptions {
                exclude 'LICENSE.txt'
                exclude 'META-INF/license.txt'
                exclude 'META-INF/notice.txt'
            }

            lintOptions {
                abortOnError false
            }
        }

        // include all resources that are placed inside src dirs
        android.sourceSets.main.resources.srcDirs mainSrcDir
        android.sourceSets.test.resources.srcDirs testSrcDir
        allSource   = android.sourceSets.main.java.srcDirs
        dependencies
        {
            testCompile junit
        }

		configurations {
			// exclude transitive deps that are not supported on android
			all {
				dependencies.all { dep ->
					excludeNonAndroidRuntime(project, dep)
				}
			}
		}
    }
    else
    {
        apply plugin: 'java'
        compileJava.options.encoding = 'UTF-8'
        allSource   = sourceSets.main.allSource
        // include all resources that are placed inside src dirs
        sourceSets.main.resources.srcDirs    mainSrcDir
        sourceSets.test.resources.srcDirs    testSrcDir
        
        dependencies
        {
            testCompile junit
        }
        
        processResources {
			filesMatching('**/version.properties')
			{
				filter{String line -> line.replace('${jadex_build_version}', rootProject.jadex_build_version)}
				filter{String line -> line.replace('${timestamp}', rootProject.timestamp)}
			}
		}

        // Set correct bootclasspath for each project, depending on sourceCompatibility
        afterEvaluate {
            setBootClassPath(project)
        }

    }

	configurations {
		// compileNoAndroidRuntime will exclude the artifact in Android APKs
		runtimeAndroid.extendsFrom runtime
		compileNoAndroidRuntime {
			dependencies.all { dep ->
				configurations.runtimeAndroid.exclude group: dep.group, module: dep.name
			}
		}
		compile.extendsFrom compileNoAndroidRuntime
	}

	// process schemas and generate schemadocs
	if (project.projectDir.toPath().resolve('src/main/schema').toFile().exists()) {
		addSchemaTasks(project)
	}

    apply plugin: 'maven'
    sourceCompatibility = 1.6
    
    uploadArchives {
    	if (project.hasProperty('repouser')) {
	        repositories {
	        	if (isCommercial(project))
	        	{
		            mavenDeployer {
		                repository(url: repo_release_commercial) {
		                	authentication(userName: repouser, password: repopassword)
		                }
		                snapshotRepository(url: repo_snapshot_commercial) {
		                	authentication(userName: repouser, password: repopassword)
		                }
		                uniqueVersion=true
		            }
		        }
		        else
		        {
		        	mavenDeployer {
		                repository(url: repo_release_noncommercial) {
		                	authentication(userName: repouser, password: repopassword)
		                }
						snapshotRepository(url: repo_snapshot_noncommercial) {
		                	authentication(userName: repouser, password: repopassword)
		                }
		                uniqueVersion=true
		            }
		        }
	        }
	    }
    }
}

// Hack, helper to generate dep-tree
task genDepList << {

	def out = new PrintStream(project.projectDir.getCanonicalPath() + '/dependencies.conf', 'UTF-8')
	project.ext.subprojectmap.entrySet().each { entry ->
		def sp = entry.getValue()
		out. println ('### ' + entry.getKey())
		def founddeps = new HashSet<String>()
		sp.configurations.each { conf ->
			conf.getAllDependencies().withType(org.gradle.api.artifacts.ProjectDependency).each { dep ->
				if (!founddeps.contains(dep.getName()))
					out.println dep.getDependencyProject().getPath()
				founddeps.add(dep.getName())
			}
		}
	}
	out.close()
}

task copyJavaDocSources(type: Copy) {
	destinationDir = new File(project.distsDir.getCanonicalPath() + '/javadocworkdir')
	gradle.ext.maindistartifacts.each { artname ->
		def sp = project.ext.subprojectmap.get(artname)
		from(sp.projectDir.getCanonicalPath() + '/src/main/java') {
			include '**/*.java'
			exclude '**/org/apache/**'
			exclude '**/impl/**'
		}
	}
	def comment = false
	
	/* Filter to fix some HTML-entity/Javadoc nonsense */
	filter { line ->
		if (line.trim().startsWith('/**'))
			comment = true
		
		if (comment) {
			line = line.replaceAll('(?<!code)>','&gt;')
			if (line.contains('*/'))
				comment = false;
		}
		return line
	}
}

task javadocZip(type: Javadoc, dependsOn: [copyJavaDocSources]) {
	def sourcedir = project.distsDir.getCanonicalPath() + '/javadocworkdir'
	source(sourcedir)
	destinationDir = new File(project.distsDir.getCanonicalPath() + '/jadex-' + jadex_build_version + '-javadoc')
	
	options.encoding 'UTF-8'
	options.docEncoding 'UTF-8'
	options.charSet 'UTF-8'
	options.quiet()
	
	options.docTitle("Jadex Active Component Platform ${project.version} API")
	options.windowTitle("Jadex Active Component Platform ${project.version} API")
	options.group('Core Packages','jadex.commons*:jadex.bridge*')
	options.group('Micro Agent Packages','jadex.micro*')
	options.group('BPMN Process Packages','jadex.bpmn*')
	options.group('BDI Agent Packages','jadex.bdi*')
	options.group('Web Service Extension Packages','jadex.extension.ws*:jadex.extension.rs*')
	options.group('2D/3D Environment Extension Packages','')
	options.group('Agent-Group-Role (AGR) Extension Packages','jadex.extension.agr*')
	
	doLast {
		def ant = new groovy.util.AntBuilder()
		ant.sequential {
			ant.delete dir: sourcedir
			ant.zip destfile: destinationDir.getCanonicalPath() + '.zip', {
				zipfileset dir: destinationDir.getCanonicalPath(), prefix: destinationDir.getName() + '/', erroronmissingdir: false
			}
			ant.delete dir: destinationDir
		}
	}
}

task exampleZips << {
	def preprocessdirfile = new File(project.distsDir.getCanonicalPath() + '/filteredexampleprojects')
	def preprocessdir = preprocessdirfile.getCanonicalPath()
	String outputdir = project.distsDir.getCanonicalPath() + '/exampleprojects/'
    String buildExcludes = 'build/**, classes/**, target/**, bin/**, .gradle/**, .idea/**, *.iml'
	gradle.ext.maindistartifacts.each { artname ->
		Project sp = project.ext.subprojectmap.get(artname)
		File exdir = new File(sp.projectDir.getCanonicalPath() + '/dist/exampleprojects')
		if (exdir.exists() && exdir.isDirectory()) {
			exdir.listFiles().each { ex ->
				preprocessdirfile.mkdirs()
				def ant = new groovy.util.AntBuilder()
				ant.sequential {
					ant.copy todir: preprocessdir + '/' + ex.getName(),
					{
						resources
						{
							fileset dir: ex.getCanonicalPath(), includes: project.ext.filterfiles, erroronmissingdir: false
						}

						filterset begintoken: '${', endtoken: '}',
						{
							filter token: 'jadex_build_version', value: jadex_build_version
						}
					}
					ant.copy todir: preprocessdir + '/' + ex.getName(),
					{
						resources
						{
							fileset dir: ex.getCanonicalPath(), excludes: project.ext.filterfiles + ', ' + buildExcludes, erroronmissingdir: false
						}
					}
					ant.zip(destfile: outputdir + ex.getName() + '.zip', basedir: preprocessdir, includes: ex.getName() + '/**')
					ant.delete dir: preprocessdir
				}
			}
		}
	}
}

task srcZip << {
	createSrcZip(maindistsuffix.substring(1), gradle.ext.maindistartifacts, isAddon(gradle.ext.selecteddists))
}

task srcZips << {
	gradle.ext.selecteddists.each { selecteddist ->
		def arts = gradle.ext.distartmap.get(selecteddist)
		createSrcZip(selecteddist, arts, selecteddist.startsWith('addon'))
	}
}

task distZip(dependsOn: [subprojects.build, srcZip, exampleZips]) {
	description	= "Build a single zip containing modules of all selected distributions. Use '-P dist=<distnames>' to specify distributions (default 'everything'). Available distibutions can be found in the first row of buildconfigs.csv."
} << {
	createDistZip(maindistsuffix.substring(1), gradle.ext.maindistartifacts, isAddon(gradle.ext.selecteddists))
}

task distZips(dependsOn: [subprojects.build, srcZips, exampleZips])  {
	description	= "Build separate zips for all selected distributions. Use '-P dist=<distnames>' to specify distributions (default 'everything'). Available distibutions can be found in the first row of buildconfigs.csv."
} << {
	gradle.ext.selecteddists.each { selecteddist ->
		def arts = gradle.ext.distartmap.get(selecteddist)
		createDistZip(selecteddist, arts, selecteddist.startsWith('addon'))
	}
}

def createDistZip(distname, arts, isaddon)
{
	def commercial = false
	arts.each { artname ->
		commercial |= isCommercial(project.ext.subprojectmap.get(artname))
	}
	println 'Distribution "' + distname + '" is ' + (commercial? 'commercial' : 'non-commercial') + ' and ' + (isaddon? 'an add-on.' : 'standalone.')
		
	def preprocessdirfile = new File(project.distsDir.getCanonicalPath() + '/filtereddistfiles')
	preprocessdirfile.mkdirs()
	def preprocessdir = preprocessdirfile.getCanonicalPath()
	def foldername = 'jadex-'  + jadex_build_version
	def zipfilename = project.distsDir.getCanonicalPath() + (commercial? '/commercial' : '/noncommercial') + '/' + 'jadex-'  + distname  + '-' + jadex_build_version + '.zip'
	def distdir = project.distsDir.getCanonicalPath()
	def ant = new groovy.util.AntBuilder()
	def extdists = new HashSet()
	
	ant.sequential {
		ant.copy todir: preprocessdir,
		{
			resources
			{
				arts.each { artname ->
					def sp = project.ext.subprojectmap.get(artname)
					fileset dir: sp.projectDir.getCanonicalPath() + '/dist/files', includes: project.ext.filterfiles, erroronmissingdir: false
				}
			}
			
			filterset begintoken: '${', endtoken: '}',
			{
				filter token: 'jadex_build_version', value: jadex_build_version
			}
		}
		if (isaddon)
		{
			ant.copy file: project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname  + '-' + jadex_build_version + '-sources.zip', tofile: preprocessdir + '/sources-' + distname + '.zip'
		}
		else
		{
			ant.copy file: project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname  + '-' + jadex_build_version + '-sources.zip', tofile: preprocessdir + '/sources.zip'
		}
		ant.zip destfile: zipfilename,
		{
			arts.each { artname ->
				def sp = project.ext.subprojectmap.get(artname)
				def spbdir = sp.buildDir.getCanonicalPath()

				if (isAndroidProject(sp)) {
					def targetFolder = '/apps/'
					if (isAndroidLibraryProject(sp)) {
						targetFolder = '/lib/'
					}
					onReleaseOutput(sp) {output ->
						zipfileset dir: output.outputFile.getParent(), prefix: foldername + targetFolder, includes:  output.outputFile.getName(), erroronmissingdir: true
					}
				} else {
					zipfileset dir: spbdir + '/libs', prefix: foldername + '/lib/', includes: '*.jar,*.war', excludes: '*-sources.jar,jadex-distribution-*.jar', erroronmissingdir: false

					def runtimeConfig = sp.configurations.runtime
					if (distname.contains('android')) {
						runtimeConfig = sp.configurations.runtimeAndroid
					}
					runtimeConfig.fileCollection {
						it instanceof org.gradle.api.artifacts.ExternalModuleDependency? it : null
					}.each { file ->
						if (!extdists.contains(file)) {
							zipfileset file: file, prefix: foldername + '/lib/'
							extdists.add(file)
						}
					}
				}
				
				zipfileset dir: spbdir + '/dist/files', prefix: foldername + '/', excludes: project.ext.filterfiles, erroronmissingdir: false

				
				def exdir = new File(sp.projectDir.getCanonicalPath() + File.separator + 'dist/exampleprojects')
				if (exdir.exists() && exdir.isDirectory()) {
					exdir.listFiles().each { ex ->
						zipfileset dir: project.distsDir.getCanonicalPath() + '/exampleprojects/', prefix: foldername + '/', includes: ex.getName() + '.zip'
					}
				}
			}
			
			zipfileset dir: preprocessdir, prefix: foldername + '/', erroronmissingdir: false
		}
		ant.delete dir: preprocessdir
	}
}

def createSrcZip(distname, arts, isaddon)
{
	def mainzipdir = 'sources/'
	String maindir = project.projectDir.getCanonicalPath()
	String zipfilename = project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname + '-' + jadex_build_version + '-sources.zip'
	def ant = new groovy.util.AntBuilder()
	ant.sequential {
		zip destfile: zipfilename,
		{
			arts.each { artname ->
				Project sp = subprojectmap.get(artname)
				// each project: sources + resources
				String prefix = mainzipdir + Paths.get(maindir).relativize(sp.projectDir.toPath()).toString() // handle nested paths correctly
				zipfileset dir: sp.projectDir.getCanonicalPath() + '/' + srcdir, prefix: prefix +'/' + srcdir,  erroronmissingdir: false
				// each project: dist directory
				zipfileset dir: sp.projectDir.getCanonicalPath() + '/dist', prefix: prefix + '/dist',  erroronmissingdir: false, excludes: '**/build/**'
				// each project: build script files
				zipfileset dir: sp.projectDir.getCanonicalPath(), prefix: prefix, includes: '*.gradle, *.properties, lib/**',  erroronmissingdir: false
			}
			// top-level build script files
			if (!isaddon) {
				zipfileset dir: maindir, prefix: mainzipdir, includes: '*.gradle, gradle.properties, gradle/wrapper/*', excludes: '.gradle'
				zipfileset dir: maindir, prefix: mainzipdir, includes: 'gradlew, gradlew.bat', filemode: 755
				zipfileset dir: maindir, prefix: mainzipdir, includes: 'src/main/buildutils/**/*'
				zipfileset dir: maindir, prefix: mainzipdir, includes: 'buildconfigs.csv'
				zipfileset dir: maindir, prefix: mainzipdir, includes: 'dependencies.conf'
			}
		}
	}
}

/* Recursively add subprojects */
def addSubproject(prefix, proj)
{
	def pname = prefix + ':' + proj.name
	project.ext.subprojectmap.put(pname, proj)
	proj.subprojects.each { sp ->
		addSubproject(pname, sp)
	}
}

/* Tests if a project is commercial. */
def isCommercial(project) {
	project.hasProperty("commercial") && project.property("commercial").toLowerCase().equals('true')
}

def isAddon(selecteddists) {
	def isaddon = true
	selecteddists.each { dist ->
		isaddon &= dist.startsWith('addon')
	}
	return isaddon
}
