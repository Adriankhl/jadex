import aos.jack.util.cursor.EnumerationCursor;
import java.util.Vector;

view Board {

    /**
     * The int [][] board represents the game board, with 0 marking
     * the hole, and 4 marking out-of-limit coordinates. Otherwise
     * there are "1" pieces and "-1" pieces. Note that we don't
     * distinguish pieces individually in this representation.
     */
    int [][] board = {
	{ 1, 1,  1,  4,  4 },
	{ 1, 1,  1,  4,  4 },
	{ 1, 1,  0, -1, -1 },
	{ 4, 4, -1, -1, -1 },
	{ 4, 4, -1, -1, -1 }
    };

    int last = 4;
    SquareIndex the_hole = new SquareIndex( 2, 2 );

    /**
     * The static int [][] move_check_table represents available
     * moves, as coordinate offsets and piece colour. E.g., with the
     * hole in <x:y>, then a "-1" piece in <x+1:y> is eligible, as is
     * a "-1" piece in <x+2,y> if there also is a "1" piece in
     * <x+1:y>.
     */
    static int [][] move_check_table = {
	// Step moves
	{ 1, 0, -1 },
	{ 0, 1, -1 },
	{ -1, 0, 1 },
	{ 0, -1, 1 },
	// Jump moves
	{ 2, 0, -1, 1, 0, 1 },
	{ 0, 2, -1, 0, 1, 1 },
	{ -2, 0, 1, -1, 0, -1 },
	{ 0, -2, 1, 0, -1, -1 },
    };

    /**
     * The moves() method computes possible moves to <x:y>,
     * represented by the SquareIndexes of pieces to move.
     */
    Vector moves(int x,int y)
    {
	Vector v = new Vector();

	for (int i=0; i<move_check_table.length; i++)
	    check( v, move_check_table[i], x, y );

	return v;
    }

    /**
     * The check() method processes a move_check_table entry, and adds
     * a SquareIndex to the Vector when the entry applies.
     */
    void check(Vector v,int [] m,int x,int y)
    {
	int x1 = x+m[0];
	int y1 = y+m[1];

	if ( get( x1, y1 ) == m[2] ) {
	    if ( m.length == 3 || get( x+m[3], y+m[4] ) == m[5] ) {
		SquareIndex s = new SquareIndex( x1, y1 );
		 v.add( s );
	    }
	}
    }
 
    int get(int x,int y)
    {
	if ( x < 0 || x >= 5 || y < 0 || y >= 5 )
	    return 4;
	return board[x][y];
    }

    int get(SquareIndex s)
    {
	return get( s.x, s.y );
    }

    void set(int v,int x,int y)
    {
	board[x][y] = v;
    }

    void set(int v,SquareIndex s)
    {
	set( v, s.x, s.y );
    }

    boolean solution()
    {
	if ( board[2][2] != 0 )
	    return false;
	for ( int i=0; i<3; i++ ) {
	    for ( int j=0; j<3; j++ ) {
		if ( board[i][j] > 0 )
		    return false;
	    }
	}
	return true;
    }

    Vector moves(SquareIndex hole)
    {
	return moves( hole.x, hole.y );
    }

    boolean isJumpMove(int x,int y)
    {
	int dx = Math.abs( the_hole.x - x );
	int dy = Math.abs( the_hole.y - y );
	return dx == 2 || dy == 2 ;
    }

    boolean isJumpMove(SquareIndex s)
    {
	return isJumpMove( s.x, s.y );
    }

    #function query
    Vector moves(logical SquareIndex $hole)
    {
	return moves( (SquareIndex)$hole.getValue() );
    }

	protected java.util.List moves = new java.util.ArrayList();

    #function query
    boolean move(logical SquareIndex $from,logical SquareIndex $to, boolean back)
    {
	SquareIndex from = (SquareIndex)$from.getValue();
	SquareIndex to = (SquareIndex)$to.getValue();

	if ( get( to.x, to.y ) != 0 )
	    return false;
	int value = get( from.x, from.y );
	if ( value != 1 && value != -1 )
	    return false;
	if(!back)
	{
		moves.add(new Integer(value));
		last = value;
	}
	else
	{
		moves.remove(moves.size()-1);
		if(moves.size()>0)
		{
			Integer l = (Integer)moves.get(moves.size()-1);
			last = l.intValue();
		}
		else
		{
			last = 4;
		}
	}
	the_hole = from;
	set( value, to );
	set( 0, from );
	return true;
    }

    #function query
    boolean hole(logical SquareIndex $s)
    {
	return $s.unify( the_hole );
    }

    #complex query
    possibleMove(logical SquareIndex $s,logical SquareIndex $t)
    {
	return hole( $t ) && new Places( moves( $t ), $s );
    }

    class Places extends EnumerationCursor {

	logical SquareIndex $s;

	Places(Vector v,logical SquareIndex $s)
	{
	    super( v.elements(), $s );
	    this.$s = $s;
	}

	public boolean bindValues(Object o) throws Exception
	{
	    return $s.unify( o );
	}
    }

}
