<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema 
	targetNamespace="http://jadex.sourceforge.net/gpmn" 
	xmlns:gpmn="http://jadex.sourceforge.net/gpmn" 
	xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" 
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	ecore:package="jadex.tools.gpmn">
	
	<!-- 
		Import Ecore.xsd to support EAnnotation / EModelElement extension 
	-->
	<xsd:import 
		schemaLocation="platform:/plugin/org.eclipse.emf.ecore/model/Ecore.xsd"
		namespace="http://www.eclipse.org/emf/2002/Ecore"/>
	
	<!-- ##################### JADEX ##################### -->
	<!-- Maybe generate / import jadex.xsd model as well?  -->
	<!-- ##################### JADEX ##################### -->


	<!-- ############# Marker Interfaces ############# -->
	
	<!--
		Interface Identifiable. Has an ID accessible from the 
		API for identification purpose extends EModelElement 
		so that it accepts EAnnotations that are used instead 
		of properties 
	-->
	<xsd:complexType name="Identifiable">
		<xsd:complexContent>
			<xsd:extension base="ecore:EModelElement">
				<!-- Has the id available via API -->
				<xsd:attribute name="id" type="xsd:ID"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<!-- 
		Marker interface AssociationTarget. Provide association of Annotations, 
		used for graph, vertex (and edge?). Extends Identifiable.
	-->
	<xsd:complexType name="AssociationTarget">
        <xsd:complexContent>
			<xsd:extension base="gpmn:Identifiable">
	        	<xsd:sequence>
	            	<xsd:element name="associations" type="xsd:IDREF"
	            		minOccurs="0" maxOccurs="unbounded"   
	            		ecore:opposite="target" ecore:reference="gpmn:Association" />
	       		</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
	<!--
		The root Object of all gpmn Objects, provides name,
		description and ncname for all gpmn objects
	-->
	<xsd:complexType name="NamedObject">
		<xsd:complexContent>
			<xsd:extension base="ecore:EModelElement">
				<xsd:attribute name="name" type="xsd:string"/>
				<xsd:attribute name="description" type="xsd:string"/>
				<xsd:attribute name="ncname" type="xsd:NCName"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
	<!-- ############# Artifacts (+ abstract container) ############# -->

	<!-- Containment for the artifacts -->
  	<xsd:complexType name="ArtifactsContainer" ecore:implements="gpmn:Identifiable" ecore:abstract="true">
    	<xsd:complexContent>
			<xsd:extension base="gpmn:NamedObject">
		    	<xsd:sequence>
		        	<xsd:element name="artifacts" type="gpmn:Artifact"
		        		minOccurs="0" maxOccurs="unbounded"
		        		ecore:opposite="artifactsContainer"/>
		   		</xsd:sequence>
	    	</xsd:extension>
	    </xsd:complexContent>
  	</xsd:complexType>
  	    
    <!-- 
    	Artifact (abstract)
    	The artifact is the containment for the associations
    	its either a textAnnotation, or a dataobject. 
    -->
  	<xsd:complexType name="Artifact" ecore:implements="gpmn:Identifiable" ecore:abstract="true">
  		<xsd:complexContent>
			<xsd:extension base="gpmn:NamedObject">
	        	<xsd:sequence>
	        		<!-- multiple associations for a single artifact -->
	            	<xsd:element name="associations" type="gpmn:Association" 
	            		minOccurs="0" maxOccurs="unbounded"
	            		ecore:opposite="source"/>
				</xsd:sequence>
	    	</xsd:extension>
	    </xsd:complexContent>
  	</xsd:complexType>
  	
  	<xsd:complexType name="TextAnnotation">
  		<xsd:complexContent>
			<xsd:extension base="gpmn:Artifact">
	    	</xsd:extension>
	    </xsd:complexContent>
  	</xsd:complexType>
  	
  	<xsd:complexType name="DataObject">
  		<xsd:complexContent>
			<xsd:extension base="gpmn:Artifact">
	    	</xsd:extension>
	    </xsd:complexContent>
  	</xsd:complexType>
  	
  	<!-- association connection -->
    <xsd:complexType name="Association" ecore:implements="gpmn:Identifiable">
		<xsd:complexContent>
			<xsd:extension base="ecore:EModelElement">
			<!-- we only support association from an 
					identifiable-node (goal, process, plan) to an artifact -->
	    		<xsd:attribute name="target" type="xsd:IDREF" 
	    			ecore:opposite="associations" ecore:reference="gpmn:AssociationTarget"  ecore:transient="true"/>
	    		<xsd:attribute name="source" type="xsd:IDREF"
	    			ecore:opposite="associations" ecore:reference="gpmn:Artifact" ecore:transient="true"/>
				<xsd:attribute name="direction" type="gpmn:DirectionType" default="in"/>
	    	</xsd:extension>
	    </xsd:complexContent>
    </xsd:complexType>

	<!-- ############# Abstract graph objects ############# -->
	<!-- 
		Abstract objects that define a graph one graph diagram or expandable
		goal. Also contains artifacts.
	-->	
	<xsd:complexType name="Graph" ecore:implements="gpmn:AssociationTarget">
		<xsd:complexContent>
			<xsd:extension base="gpmn:ArtifactsContainer">
	        	<xsd:sequence>
	            	<xsd:element name="vertices" type="gpmn:Vertex" 
	            		minOccurs="0" maxOccurs="unbounded"
	            		ecore:opposite="graph"/>
	            	<xsd:element  name="sequenceEdges" type="gpmn:Edge"
	            		minOccurs="0" maxOccurs="unbounded"
	            		ecore:opposite="graph" />
	       		</xsd:sequence>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>
	
	<xsd:complexType name="Vertex" ecore:implements="gpmn:NamedObject">
		<xsd:complexContent>
			<xsd:extension base="gpmn:AssociationTarget">
				<xsd:sequence>
		            <xsd:element  name="outgoingEdges" type="xsd:IDREF"
		            	maxOccurs="unbounded" minOccurs="0"
		            	ecore:opposite="source" ecore:reference="gpmn:Edge" />
		            <xsd:element name="incomingEdges" type="xsd:IDREF" 
		            	maxOccurs="unbounded" minOccurs="0"
		            	ecore:opposite="target" ecore:reference="gpmn:Edge" />
	       		</xsd:sequence>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>
	
	<xsd:complexType name="Edge" ecore:implements="gpmn:NamedObject">
		<xsd:complexContent>
			<xsd:extension base="gpmn:AssociationTarget">
		    	<xsd:attribute name="source" type="xsd:IDREF" 
		    		ecore:opposite="outgoingEdges" ecore:reference="gpmn:Vertex" ecore:transient="true"/>
		    	<xsd:attribute name="target" type="xsd:IDREF" 
		    		ecore:opposite="incomingEdges" ecore:reference="gpmn:Vertex" ecore:transient="true"/>
				<xsd:attribute name="isDefault" type="xsd:boolean"/>
	    	</xsd:extension>
	    </xsd:complexContent>
    </xsd:complexType>
    
    <!--
    	InterGrap[Vertex|Edge] is a connection between two vertices of different graphs
    	or two Graphs since a vertex can also be a graph. The InterGraph elements can
    	reference any URI as type.
    -->
    
    <!-- InterGraphVertex can contain any URI as incoming/outgoing InterGraphEdge id's -->
    <xsd:complexType name="InterGraphVertex" ecore:implements="gpmn:NamedObject">
		<xsd:complexContent>
			<xsd:extension base="gpmn:AssociationTarget">
				<!-- see page 5 of http://www.eclipse.org/modeling/emf/docs/overviews/FeatureMap.pdf -->
    			<xsd:choice maxOccurs="unbounded" minOccurs="0" ecore:name="interGraphMessages">
    				<xsd:element name="incomingInterGraphEdges" type="xsd:anyURI"
    					 maxOccurs="unbounded" minOccurs="0" 
    					 ecore:reference="gpmn:InterGraphEdge" ecore:opposite="target"/>
           			<xsd:element name="outgoingInterGraphEdges" type="xsd:anyURI"
           				maxOccurs="unbounded" minOccurs="0"
           				ecore:reference="gpmn:InterGraphEdge" ecore:opposite="source"/>
           		</xsd:choice>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>

	<!-- InterGraphEdge can contain any URI as source/target GraphVertex id -->
    <xsd:complexType name="InterGraphEdge" ecore:implements="gpmn:NamedObject">
		<xsd:complexContent>
			<xsd:extension base="gpmn:AssociationTarget">
		    	<!-- the messaging edges in this diagram -->
		    	<xsd:attribute name="source" type="xsd:anyURI"
		    		ecore:opposite="incomingInterGraphEdges" ecore:reference="gpmn:InterGraphVertex"/>
		    	<xsd:attribute name="target" type="xsd:anyURI"
		    		ecore:opposite="outgoingInterGraphEdges" ecore:reference="gpmn:InterGraphVertex"/>
	    	</xsd:extension>
	    </xsd:complexContent>
    </xsd:complexType>

	<!-- ############# Goal [Process|Plan] Modeling Notation ############# -->
	
	<!-- Root diagram contains goal-processes and artifacts -->
	<xsd:complexType name="GpmnDiagram" ecore:implements="gpmn:Identifiable">
		<xsd:complexContent>
			<xsd:extension base="gpmn:Graph">
				<xsd:sequence>
					<xsd:element name="processes" type="gpmn:Process"
						minOccurs="0" maxOccurs="unbounded"
						ecore:opposite="gpmnDiagram"/>
					<xsd:element name="messages" type="gpmn:MessagingEdge"
						minOccurs="0" maxOccurs="unbounded"
						ecore:opposite="gpmnDiagram"/>
				</xsd:sequence>
				<xsd:attribute name="title" type="xsd:string"/>
				<xsd:attribute name="author" type="xsd:string"/>
				
				<xsd:attribute name="revision" type="xsd:string" use="optional"/>
				<xsd:attribute name="version" use="optional" default="2.0"/>

			</xsd:extension>
		</xsd:complexContent>
    </xsd:complexType>
    
    <!-- various types of goals -->
    <xsd:simpleType name="GoalType">
    	<xsd:restriction base="xsd:string">
      
      		<!-- metagoal, subprocess -->
      		<xsd:enumeration value="MetaGoal"/>
      		<xsd:enumeration value="SubProcessGoal"/>
    
    		<!-- jadex buildin goals -->
    		<xsd:enumeration value="MaintainGoal"/>
      		<xsd:enumeration value="AchieveGoal"/>
      		<xsd:enumeration value="PerformGoal"/>
      		<xsd:enumeration value="QueryGoal"/>
      		
      		<!-- go4flex gpmn additions  -->
      		<xsd:enumeration value="SubProcessGoal"/>
      		<xsd:enumeration value="SequentialGoal"/>
      		<xsd:enumeration value="ParallelGoal"/>
      		<xsd:enumeration value="MessageGoal"/>

    	</xsd:restriction>
  	</xsd:simpleType>
  	
  	<!-- various types of connections -->
    <xsd:simpleType name="EdgeType">
    	<xsd:restriction base="xsd:string">
      
      		<!-- subgoal, plan, association -->
      		<xsd:enumeration value="SubGoalEdge"/>
      		<xsd:enumeration value="PlanEdge"/>
      		<xsd:enumeration value="MessageEdge"/>

    	</xsd:restriction>
  	</xsd:simpleType>
  	
	<xsd:simpleType name="DirectionType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="in"/>
			<xsd:enumeration value="out"/>
			<xsd:enumeration value="inout"/>
			<xsd:enumeration value="fixed"/>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:complexType name="Parameter">
		<xsd:attribute name="name" type="xsd:string" default=""/>
		<xsd:attribute name="type" type="xsd:string" default=""/>
		<xsd:attribute name="value" type="xsd:string" default=""/>
		<xsd:attribute name="direction" type="gpmn:DirectionType" use="optional" default="in">
			<xsd:annotation>
				<xsd:documentation>The direction can be used to explicitly declare e.g. result parameters (out) or parameters that are both (inout). Per default parameters are in.</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
    </xsd:complexType>
  	
    <!-- ############# Types of Vertices ############# -->
    
    <!-- Plans are vertex with a URI to the bpmn plan -->
    <xsd:complexType name="	ParameterizedVertex">
    	<xsd:complexContent>
	    	<xsd:extension base="gpmn:Vertex">
		    	<xsd:sequence>
						<xsd:element name="parameter" type="gpmn:Parameter" minOccurs="0" maxOccurs="unbounded"/>
		    	</xsd:sequence>
	    		<xsd:attribute name="sequential" type="xsd:boolean" default="false"/>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>			
    
    <!-- 
    	A Process is a Graph with a reference to the gpmnDiagram. The process is
    	used to group some subsequent goals/plan/items etc...
     -->
    <xsd:complexType name="Process" ecore:implements="gpmn:InterGraphVertex">
    	<xsd:complexContent>
	    	<xsd:extension base="gpmn:Graph">
	    		<xsd:sequence>
	    			<!--
	    			<xsd:element name="subProcesses" type="gpmn:Process"
						minOccurs="0" maxOccurs="unbounded"
						ecore:opposite="topProcess" ecore:containment="false"/>
					-->
					<xsd:element name="imports" type="xsd:string"
						minOccurs="0" maxOccurs="unbounded"/>
	    		</xsd:sequence>
	    		<xsd:attribute name="package" type="xsd:string"/>
		        <xsd:attribute name="looping" type="xsd:boolean"/>
		    </xsd:extension>
		</xsd:complexContent>
    </xsd:complexType>

    <!-- 
    	Goals are a specialization of a Vertex. They have a reference 
    	to the process a description and name.
    	A Goal is abstract, there are various specializations of a Goal
    	like MetaGoal, AchieveGoal, PerformGoal ...
     -->
    <xsd:complexType name="Goal" ecore:abstract="true">
    	<xsd:complexContent>
	    	<xsd:extension base="gpmn:ParameterizedVertex">
	    		<xsd:sequence>

	    			<!-- copied attributes and elements from jadex-2.0.xsd -->
	    			
					<xsd:element name="unique" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>If a goal is declared unique only one instance of this type is allowed being adopted at any one time. To determine if two goals are equal the type and parameters are used. Parameters that should not be considered can explicitly be excluded. </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="creationcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>A condition that creates a new goal of the given type when triggered. If binding-parameters are used for each possible binding a new goal is created. </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="creationcondition_language" type="xsd:string" default="jcl" minOccurs="0" />
					<xsd:element name="contextcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The context condition is checked during the whole execution time of a goal. If it becomes invalid the goal will become suspended and is not actively pursued until reactivation.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="contextcondition_language" type="xsd:string" default="jcl" minOccurs="0" />
					<xsd:element name="dropcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>If the dropcondition triggers the goal instance is dropped.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="dropcondition_language" type="xsd:string" default="jcl"  minOccurs="0" />
					<xsd:element name="recurcondition" type="xsd:string" minOccurs="0"/>
					<xsd:element name="deliberation" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The goal deliberation setting for the easy deliberation strategy.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					
					<!-- context handler (changes on context after goal finished -->
					<xsd:element name="onSuccessHandler" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
					<xsd:element name="onSkipHandler" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
					<xsd:element name="onFailureHandler" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
					
					
					
				</xsd:sequence>
				<xsd:attribute name="retry" type="xsd:boolean" default="true">
					<xsd:annotation>
						<xsd:documentation>The retry flag can be used to determine the behaviour on plan failures. If retry is turned on (by default it is on) and a plan fails to achieve the considered goal another plan from the applicables plan list will be chosen for execution.</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="randomselection" type="xsd:boolean" default="false">
					<xsd:annotation>
						<xsd:documentation>Random selection can be used to choose among applicable plans for a given goal randomly. If used this flag makes the order of plan declaration within the ADF unimportantly, i.e. only random selection is only applied to plans of the same priority and rank (cf. mlreasoning comment). The mechanism is implemented in the jadex.impl.DefaultMetaLevelReasoner.</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="retrydelay" type="xsd:long" default="0">
					<xsd:annotation>
						<xsd:documentation>With the retrydelay the delay between the failure of one plan and the execution of the next plan can be specified in milliseconds.</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="exclude" default="when_tried">
					<xsd:annotation>
						<xsd:documentation>The exclude flag can be specified when a plan will be excluded from the applicable plan list. The default is when_tried, which means that a candidate is excluded independently of its state when executed one time for a goal. Other options are when_succeeded, when_failed and never.</xsd:documentation>
					</xsd:annotation>
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:enumeration value="never"/>
							<xsd:enumeration value="when_tried"/>
							<xsd:enumeration value="when_failed"/>
							<xsd:enumeration value="when_succeeded"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>
				<xsd:attribute name="posttoall" type="xsd:boolean" default="false">
					<xsd:annotation>
						<xsd:documentation>When post-to-all is set to true (default is false), a goal is dispatched to all candidates of the applicable plan list at once. This process will only happen one time regardless of the retry settings. A post-to-all goal has implicit or semantics meaning that if one plan achieves the goal all others will be terminated.</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="recalculate" type="xsd:boolean" default="true">
					<xsd:annotation>
						<xsd:documentation>When recalculate is set to false (default is true) the applicable candidates list will be calculated only once for the goal. Otherwise it will be recalculated whenever the goal should be processed.</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="recur" type="xsd:boolean" default="false"/>
				<xsd:attribute name="recurdelay" type="xsd:long" default="0"/>
				
				<!-- some attributes from agile demonstrator -->
				<!--
				<xsd:attribute name="priority" type="xsd:int"/>
				<xsd:attribute name="skipcondition" type="xsd:string"/>
				<xsd:attribute name="contextcondition" type="xsd:string"/>
				-->

				<!-- the type of this goal -->
	    		<xsd:attribute name="goalType" type="gpmn:GoalType"/>
	    		
		    </xsd:extension>
		</xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="PerformGoal">
		<xsd:annotation>
			<xsd:documentation>A perform goal aims at executing actions.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="gpmn:Goal">
				<!-- defaults the type of goal (some editors may show an error but this is ok!) - ->
	    		<xsd:attribute fixed="MaintainGoal" name="goalType"  type="gpmn:GoalType"/>
	    		-->
	    	</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
	<xsd:complexType name="AchieveGoal">
		<xsd:annotation>
			<xsd:documentation>An achieve goal aims at bringing about a target state.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="gpmn:Goal">
				<xsd:sequence>
					<xsd:element name="targetcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The target condition can be used to specify a desired world state representing goal success.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="targetcondition_language" type="xsd:string" default="jcl" minOccurs="0" />
					<xsd:element name="failurecondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Can be used to explicitly state when a goal cannot be pursued any longer and is failed. </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="failurecondition_language" type="xsd:string" default="jcl" minOccurs="0" />
				</xsd:sequence>
				<!-- defaults the type of goal (some editors may show an error but this is ok!) - ->
	    		<xsd:attribute fixed="AchieveGoal" name="goalType"  type="gpmn:GoalType"/>
	    		-->
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
	<xsd:complexType name="QueryGoal">
		<xsd:annotation>
			<xsd:documentation>A query goal aims at retrieving information.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="gpmn:Goal">
				<xsd:sequence>
					<xsd:element name="targetcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>A query goal has the implicit target condition that none of its out parameters may null.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="targetcondition_language" type="xsd:string" default="jcl" minOccurs="0" />
					<xsd:element name="failurecondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Can be used to explicitly state when a goal cannot be pursued any longer and is failed. </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="failurecondition_language" type="xsd:string" default="jcl" minOccurs="0" />
				</xsd:sequence>
				<!-- defaults the type of goal (some editors may show an error but this is ok!) - ->
	    		<xsd:attribute fixed="QueryGoal" name="goalType"  type="gpmn:GoalType"/>
	    		-->
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
	<xsd:complexType name="MaintainGoal">
		<xsd:annotation>
			<xsd:documentation>A maintain goal aims at preserving a certain state.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="gpmn:Goal">
				<xsd:sequence>
					<xsd:element name="maintaincondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The mandatory maintain condition represents a world state that should be monitored and re-established whenever it gets violated. </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="maintaincondition_language" type="xsd:string" default="jcl" minOccurs="0" />
					<xsd:element name="targetcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>A specalisation of the maintain condition taht should be re-established when the maintain condition is violated.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="targetcondition_language" type="xsd:string" default="jcl" minOccurs="0" />
				</xsd:sequence>
				<!-- defaults the type of goal (some editors may show an error but this is ok!) - ->
	    		<xsd:attribute fixed="MaintainGoal" name="goalType"  type="gpmn:GoalType"/>
	    		-->
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
    <!-- 
    	SubProcessGoals are goals with a goalref to anothers process goal
    -->
    <xsd:complexType name="SubProcessGoal">
    	<xsd:complexContent>
	    	<xsd:extension base="gpmn:Goal">
	    		<xsd:attribute name="goalref" type="xsd:string"/>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>
	
	<!-- 
    	SequentialGoals are multiple AchiveGoals.
    	(Due to EMF Problems its currently not a subclass from AchieveGoal!)
    -->
    <xsd:complexType name="SequentialGoal">
    	<xsd:complexContent>
	    	<!-- 
	    	<xsd:extension base="gpmn:AchieveGoal">
	    	</xsd:extension>
	    	-->
	    	<xsd:extension base="gpmn:Goal">
	    		<xsd:sequence>
					<xsd:element name="targetcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The target condition can be used to specify a desired world state representing goal success.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="targetcondition_language" type="xsd:string" default="jcl" minOccurs="0" />
					<xsd:element name="failurecondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Can be used to explicitly state when a goal cannot be pursued any longer and is failed. </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="failurecondition_language" type="xsd:string" default="jcl" minOccurs="0" />
				</xsd:sequence>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>
	
	<!-- 
    	ParallelGoals are multiple AchiveGoals.
    	(Due to EMF Problems its currently not a subclass from AchieveGoal!)
    -->
    <xsd:complexType name="ParallelGoal">
    	<xsd:complexContent>
	    	<!--
	    	<xsd:extension base="gpmn:AchieveGoal">
	    	</xsd:extension>
	    	-->
	    	<xsd:extension base="gpmn:Goal">
	    		<xsd:sequence>
					<xsd:element name="targetcondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>The target condition can be used to specify a desired world state representing goal success.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="targetcondition_language" type="xsd:string" default="jcl" minOccurs="0" />
					<xsd:element name="failurecondition" type="xsd:string" minOccurs="0">
						<xsd:annotation>
							<xsd:documentation>Can be used to explicitly state when a goal cannot be pursued any longer and is failed. </xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element name="failurecondition_language" type="xsd:string" default="jcl" minOccurs="0" />
				</xsd:sequence>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>

	<!--  
		MessagingGoals are InterGraphVertex and implements Goal.
		The MessageVertex is a simple first idea of communication between
		Goal-Processes.
	-->
	<xsd:complexType ecore:implements="gpmn:InterGraphVertex" name="MessageGoal">
    	<xsd:complexContent>
	    	<xsd:extension base="gpmn:Goal">
	    		<!-- defaults the type of goal - ->
	    		<xsd:attribute fixed="MessageGoal" name="goalType" type="gpmn:GoalType"/>
	    		-->
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>

	 <!-- Plans are vertex with a URI to the bpmn plan -->
    <xsd:complexType name="Plan">
    	<xsd:complexContent>
	    	<xsd:extension base="gpmn:ParameterizedVertex">
	    		<xsd:attribute name="bpmnPlan" type="xsd:anyURI"/>
	    		<xsd:attribute name="role" type="xsd:string"/>
	    		<xsd:attribute name="priority" type="xsd:int" use="optional" default="0">
					<xsd:annotation>
						<xsd:documentation>The priority can be used for controlling the plan selection process (default priority is 0). Plans with higher priority have precedence for plans with lower priority.</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
	    	</xsd:extension>
	    </xsd:complexContent>
	</xsd:complexType>
	
	<!-- ############# Types of Edges ############# -->

	<!-- SubGoalEdge are a Edges -->
    <xsd:complexType name="	ParameterizedEdge" ecore:implements="gpmn:NamedObject" ecore:abstract="true">
		<xsd:complexContent>
			<xsd:extension base="gpmn:Edge">
				<xsd:sequence>
					<xsd:element name="parameterMapping" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
				<xsd:attribute name="sequentialOrder" type="xsd:int" default="0"/>
	    	</xsd:extension>
	    </xsd:complexContent>
    </xsd:complexType>

	<!-- SubGoalEdge are a Edges -->
    <xsd:complexType name="SubGoalEdge" ecore:implements="gpmn:NamedObject">
		<xsd:complexContent>
			<xsd:extension base="gpmn:ParameterizedEdge">
	    	</xsd:extension>
	    </xsd:complexContent>
    </xsd:complexType>
    
    <!-- PlanEdge are a Edges -->
    <xsd:complexType name="PlanEdge" ecore:implements="gpmn:NamedObject">
		<xsd:complexContent>
			<xsd:extension base="gpmn:ParameterizedEdge">
	    	</xsd:extension>
	    </xsd:complexContent>
    </xsd:complexType>

    <!-- Messaging edges are a InterGraphEdges with a message string -->
    <xsd:complexType name="MessagingEdge" ecore:implements="gpmn:NamedObject">
		<xsd:complexContent>
			<xsd:extension base="gpmn:InterGraphEdge">
		        <!-- 
	    			Removed! Don't use opposite on source and target - this results
	    			in two features with the same name. 
	    		-->
		        <!--  <xsd:attribute name="gpmnDiagram" type="xsd:IDREF" ecore:opposite="messages" ecore:referenc="GpmnDiagram" ecore:containment="false" ecore:transient="true"/> -->
		    	<xsd:attribute name="message" type="xsd:string"/>
	    	</xsd:extension>
	    </xsd:complexContent>
    </xsd:complexType>
    
	<!-- ############# Go4Flex Context ############# -->
	
	<xsd:complexType name="Context" ecore:implements="gpmn:Identifiable">
		<xsd:complexContent>
			<xsd:extension base="gpmn:Artifact">
				<xsd:sequence>
					<!--
					<xsd:element name="handler" type="xsd:IDREF" 
						ecore:opposite="context" ecore:reference="gpmn:ContextHandler" ecore:containment="false" minOccurs="0" maxOccurs="unbounded"/> 
					-->
					<xsd:element name="elements" type="gpmn:ContextElement" ecore:opposite="context" minOccurs="0" maxOccurs="unbounded" />
					<xsd:element name="roles" type="gpmn:Role" minOccurs="0" maxOccurs="unbounded" />
					<xsd:element name="groups" type="gpmn:Group" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
				<xsd:attribute name="types" type="xsd:anyURI"/>
			</xsd:extension>
		</xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="ContextElement">
		<xsd:complexContent>
			<xsd:extension base="gpmn:Identifiable">
				<xsd:attribute name="context" type="xsd:IDREF" ecore:opposite="elements" ecore:reference="gpmn:Context" ecore:transient="true"/>
				<xsd:attribute name="name" type="xsd:string" default=""/>
				<xsd:attribute name="type" type="xsd:string" default=""/>
				<xsd:attribute name="initialValue" type="xsd:string" default=""/>
				<xsd:attribute name="set" type="xsd:boolean" default="false"/>
				<xsd:attribute name="dynamic" type="xsd:boolean" default="false"/>
				<!-- <xsd:attribute name="restriction" type="xsd:string"/>  -->
			</xsd:extension>
		</xsd:complexContent>
    </xsd:complexType>
    
    <!--
    <xsd:complexType name="ContextHandler">
    	<!- - removed due to double entry handler in context - ->
		<xsd:attribute name="context" type="xsd:IDREF" ecore:opposite="handler" ecore:reference="gpmn:Context" ecore:containment="false" ecore:transient="true"/>
		<xsd:attribute name="expression" type="xsd:string"/>
    </xsd:complexType>
    -->
    
    <xsd:complexType name="Role" ecore:imlements="gpmn:Identifiable">
		<xsd:complexContent>
			<xsd:extension base="gpmn:NamedObject">
				<xsd:attribute name="personType" type="xsd:string"/>
				<xsd:attribute name="initialPerson" type="xsd:string"/>
			</xsd:extension>
		</xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="Group" ecore:imlements="gpmn:Identifiable">
		<xsd:complexContent>
			<xsd:extension base="gpmn:NamedObject">
				<xsd:sequence>
					<xsd:element name="members" type="xsd:string" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
				<xsd:attribute name="head" type="xsd:string"/>
				<xsd:attribute name="coordinator" type="xsd:string"/>
			</xsd:extension>
		</xsd:complexContent>
    </xsd:complexType>


</xsd:schema>