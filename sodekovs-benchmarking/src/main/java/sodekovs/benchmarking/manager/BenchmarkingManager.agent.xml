
<!-- <H3>Benchmarking Manager</H3> Responsible for generating workload /faultload 
	according to specified schedule xml file. -->

<agent xmlns="http://jadex.sourceforge.net/jadex" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://jadex.sourceforge.net/jadex
	                    http://jadex.sourceforge.net/jadex-bdi-2.0.xsd"
	name="BenchmarkingManager" package="sodekovs.benchmarking.manager">

	<imports>
		<!-- <import>jadex.base.contextservice.*</import> <import>jadex.base.appdescriptor.*</import> 
			<import>jadex.extension.envsupport.math.*</import> -->
		<import>jadex.base.fipa.*</import>
		<import>java.util.Map</import>
		<import>java.util.HashMap</import>
		<import>java.util.Random</import>
		<import>jadex.commons.*</import>
		<import>jadex.bridge.service.*</import>
		<import>jadex.commons.future.*</import>
		<import>jadex.simulation.helper.*</import>		
		<import>jadex.bridge.service.types.clock.*</import>
		<import>sodekovs.benchmarking.model.*</import>
		<import>sodekovs.benchmarking.manager.*</import>
		<import>sodekovs.benchmarking.services.*</import>
	</imports>


	<capabilities>
		<!-- use capability that logs the memory consumption -->
		<capability name="memoryLoggerCap" file="sodekovs.util.logger.MemoryLogger" />
	</capabilities>



	<beliefs>

		<!-- The parsed schedule xml file. -->
		<belief name="schedule" class="Schedule" />

		<!-- Information about the SuT. -->
		<!--  <belief name="suTinfo" class="SuTinfo" />-->

		<!-- Reference to the XML file that contains the schedule description. 
			This file is parsed on agent start. The reference to the file is passes by 
			the surrounding application file description. -->
		<!-- <belief name="scheduleDescriptionFile" class="String">
			<fact>"../sodekovs-benchmarking/src/main/java/jadex/benchmarking/examples/TestBenchmark2.xml"
			</fact>
		</belief> -->

		<!-- Store information about the status of the executed benchmark: preparing_start, 
			running, terminated. -->			
		<belief name="benchmarkStatus" class="Map">
		<!-- HashMap used as: new HashMap<Integer,String> Integer is the localID of the benchmark -->
			<fact>new HashMap()</fact>
		</belief>

		<!-- Reference to the memory Loger Capability -->
		<belief name="MemoryLogerID" class="String">
			<fact> String.valueOf(new java.util.Random().nextInt())</fact>
			<assignto ref="memoryLoggerCap.MemoryLoggerID" />
		</belief>
		
		
		
		<!-- NEW ******************************************************************************************************** -->
		<!-- NEW ******************************************************************************************************** -->
		<!-- NEW ******************************************************************************************************** -->
		
		
		<!-- Used to manage reference the between calling service and finished benchmark: Which service call corresponds to which benchmark? Caller ID is the time when the benchmark was init. (long); The value (int) is the local benchmark counter. -->
		<belief name="callerBenchmarkReference" class="Map">
			<!-- HashMap used as: new HashMap<Long,Integer> -->
			 <fact>new HashMap()</fact>
		</belief>
	
	<!-- Contains two information for each conducted benchmark: simulationFacts and  observedEventsMap. Key is the benchmarkCounter, which is incremented automatically.-->
		<belief name="factsAboutAllBenchmarks" class="Map">
		<!-- HashMap used as: new HashMap<Integer,HashMap> -->
			<fact>new HashMap()</fact>
		</belief>
		
		<!--  Maps the benchmarks to the local ID of the benchmark -->
		<belief name="allBenchmarks" class="Map">
		<!-- HashMap used as: new HashMap<Int,Schedule> -->
			<fact>new HashMap()</fact>
		</belief>
				
		
		<!-- Counts the number of benchmark that have been executed. Is also used as ID for the benchmarks to enable parallel execution. -->
		<belief name="benchmarkCounter" class="int">
			<fact>0</fact>
		</belief>
		
		<!-- Returns the number of currently running benchmark on this agent. -->
		<belief name="numberOfRunningBenchmarks" class="int">
			<fact>0</fact>
		</belief>
		
		<!-- NEW ******************************************************************************************************** -->
		<!-- NEW ******************************************************************************************************** -->
		<!-- NEW ******************************************************************************************************** -->

	</beliefs>


	<goals>
		<!-- Used to start execution of one benchmark. -->
		<performgoal name="startExecution" retry="false" exclude="never">
			<!-- Args required to start application; This arg is optional: only required if called 
				by an SimulationAgent -->
			<parameter name="applicationConf" class="Map" />
			<!-- The name (id) of the application; This arg is optional: only required if called 
				by an SimulationAgent -->
			<parameter name="clientConf" class="HashMap" />
			<!-- Reference to the BenchmarkingReferenceFile; Mandatory -->
			<parameter name="benchmarkingDefinitionFile" class="String" />
			<!-- The timestamp which serves as ID for the calling service. -->
			<parameter name="callerID" class="Long" />
		</performgoal>
	</goals>

	<plans>
		<!-- Responsible to manage execution of benchmark. -->
		<plan name="runtime_manager">
			<body class="InitBenchmarkingPlan" />
			<parameter name="applicationConf" class="Map">
				<goalmapping ref="startExecution.applicationConf" />
			</parameter>
			<parameter name="clientConf" class="HashMap">
				<goalmapping ref="startExecution.clientConf" />
			</parameter>
			<parameter name="benchmarkingDefinitionFile" class="String">
				<goalmapping ref="startExecution.benchmarkingDefinitionFile" />
			</parameter>
			<parameter name="callerID" class="Long">
				<goalmapping ref="startExecution.callerID" />
			</parameter>
			<trigger>
				<goal ref="startExecution" />
			</trigger>
		</plan>
	</plans>



	<properties>
		<!-- The environment may throw exceptions when executing property listeners 
			and these listeners are not valid any longer. This leads to normal plan failure 
			and can therefore be ignored. -->
		<property name="logging.level">java.util.logging.Level.WARNING</property>
		<property name="debugging">false</property>
		<!-- <property name="dfservice" class="IFuture">SServiceProvider.getService($scope.getServiceProvider(), 
			IDF.class, RequiredServiceInfo.SCOPE_PLATFORM)</property> -->
	</properties>


	<services>
		<providedservice class="IBenchmarkingExecutionService">
			<implementation>new BenchmarkingExecutionService($scope)
			</implementation>
		</providedservice>
		<requiredservice name="clockservice" class="IClockService">
			<binding scope="platform" />
		</requiredservice>
	</services>


</agent>