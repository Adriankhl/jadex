<!--
	<H3>The control center agent</H3>

	Main platform administration user interface.
-->

<agent xmlns="http://jadex.sourceforge.net/jadex-bdi"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://jadex.sourceforge.net/jadex-bdi
	                    http://jadex.sourceforge.net/jadex-bdi-2.0.xsd"
	name="JCC" package="jadex.tools.jcc">

<!--
	Ist schon witzig das mit dem JCC und den Plugins die dieser lädt. Schau mal nach oben was bei 'package=..' steht :)
	Diese Jcc.agent.xml liegt zwar im distributed Ordner, aber die Komponente die diese xml Datei interpretiert setzt den
	'Kontext' dieser xml datei auf den runtimes ordner. Das hat enorme Auswirkungen:
	 - Ganz unten wird ein 'new new AgentControlCenter(...)' ausgeführt. Dabei wird das AgentControlCenter aus runtimetools,
	   und nicht aus distributed geladen;
	   ergo: das Kopieren von AgentControlCenter, ControlCenter, und ControlCenterWindow in den distributed Ordner war unnötig,
	   denn es werden nur die runtimetools Varianten verwendet; schon lustig :)
	 - Die JCC.agnt.xml erfüllt aber ihren Zweck, da ich eigene Pluings laden kann, vor allem 
	   jadex.distributed.tools.distributionmonitor.DistributionMonitorPlugin
	   und durch die package Angabe jadex.distributed.tools.distributionmonitor wird auch genau festgelegt welche Klasse es in
	   welchem Ordner ist
	- natürlich gilt das gleich auf für das StarterPanel Plugin in distributed, von dem ich am Anfang dachte, dass es dafür
	  verantwortlich war, dass der DistributionMonitor nicht geladen werden konnte, was nicht der Fall war; der Grund wieso der
	  Distribution Monitor nicht geladen werden konnte war ... hab ich vergessen ...
	  auf jeden fall wird das StarterPanel aus runtimetools und nicht aus distributed geladen
	
	Kurz: alles ist ok und läuft wie es soll. Es gibt zwar ein paar redundante Klassen, die entfernet werden können, aber
	      das kann noch etwas warten bzw. ist nicht für Umsetzung wichtig.
	      

-->

<!--
<agent xmlns="http://jadex.sourceforge.net/jadex-bdi"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://jadex.sourceforge.net/jadex-bdi
	                    http://jadex.sourceforge.net/jadex-bdi-2.0.xsd"
	name="JCC" package="jadex.distributed.tools.jcc"> -->
	<!-- auf den eigenen JCC in distributed umstellen, damit dort auch das richtige AgentControlCenter und ControlCenter gefunden werden kann --> 
   <imports>
      <import>jadex.base.fipa.*</import>
   </imports>

	<capabilities>
		<capability name="cms" file="jadex.bdi.planlib.cms.CMS" />
		<capability name="df" file="jadex.bdi.planlib.df.DF" />
		<!--  <capability name="toolcap" file="jadex.tools.common.Tool" />-->
		<!-- <capability name="loggercap" file="jadex.tools.logger.Logger"/> -->
		<capability name="testcentercap" file="jadex.tools.testcenter.TestCenter"/>
	</capabilities>

	<beliefs>
		<belief name="jcc" class="AgentControlCenter" />

		<beliefsetref name="agents">
			<concrete ref="cms.agents"/> <!-- kein package identifier, sondern einfach nur ein Name; der Punkt hat keine runtime Bedeutung, sondern ist nur syntaktischer Zucker; wie wäre es mit einem | oder $ oder & oder % um dies besser deutlich zu machen? -->
		</beliefsetref>

		<beliefref name="testcase_timeout">
			<concrete ref="testcentercap.timeout"/>
		</beliefref>
	</beliefs>

	<goals>
		<achievegoalref name="cms_create_agent">
			<concrete ref="cms.cms_create_agent" />
		</achievegoalref>

		<achievegoalref name="cms_destroy_agent">
			<concrete ref="cms.cms_destroy_agent" />
		</achievegoalref>
		
		<achievegoalref name="cms_suspend_agent">
			<concrete ref="cms.cms_suspend_agent" />
		</achievegoalref>
		
		<achievegoalref name="cms_resume_agent">
			<concrete ref="cms.cms_resume_agent" />
		</achievegoalref>

		<achievegoalref name="cms_shutdown_platform">
			<concrete ref="cms.cms_shutdown_platform" />
		</achievegoalref>

		<achievegoalref name="cms_search_agents">
			<concrete ref="cms.cms_search_agents" />
		</achievegoalref>
      
        <achievegoalref name="df_register">
            <concrete ref="df.df_register"/>
        </achievegoalref>
        
        <achievegoalref name="df_deregister">
            <concrete ref="df.df_deregister"/>
        </achievegoalref>
        
        <achievegoalref name="df_search">
            <concrete ref="df.df_search"/>
        </achievegoalref>
      
		<!-- <performgoalref name="manage_tool">
			<concrete ref="toolcap.manage_tool" />
		</performgoalref>

		<achievegoalref name="tool_request">
			<concrete ref="toolcap.tool_request" />
		</achievegoalref> -->
		
		<!-- <achievegoalref name="logger_tool_request">
			<concrete ref="loggercap.tool_request" />
		</achievegoalref>
		
		<performgoalref name="logger_manage_tool">
			<concrete ref="loggercap.manage_tool" />
		</performgoalref> -->

		<performgoalref name="perform_test">
			<concrete ref="testcentercap.perform_test"/>
		</performgoalref>
	</goals>

	<plans>
		<!-- <plan name="agent_list_update">
			<body class="AgentListUpdatePlan" />
			<trigger>
				<factadded ref="agents"/>
				<factremoved ref="agents"/>
			</trigger>
		</plan> -->
		
		<!-- <plan name="agent_list_update">
			<body class="AgentListUpdatePlan" />
			<!- - <waitqueue>
				<factadded ref="agents"/>
				<factremoved ref="agents"/>
			</waitqueue> - ->
		</plan> -->

		<!-- <plan name="receiver">
			<body class="MailPlan" />
			<trigger>
				<messageevent ref="fipcmsg" />
				<messageevent ref="agent_inform"/>
			</trigger>
		</plan> -->
	</plans>

	<events>
		<messageevent name="fipcmsg" type="fipa" />

		<!-- Message to issue a request to an observed component. -->
		<messageevent name="tool_request" type="fipa" direction="send">
			<parameter name="performative" class="String" direction="fixed">
				<value>"request"</value>
			</parameter>
			<parameter name="ontology" class="String" direction="fixed">
				<value>"jadex.tools"</value>
			</parameter>
			<parameter name="language" class="String" direction="fixed">
				<value>SFipa.JADEX_XML</value>
			</parameter>
		</messageevent>
		
		<!-- Message to issue a log request to an component. -->
		<!-- <messageevent name="logger_tool_request" type="fipa" 	direction="send">
			<parameter name="performative" class="String" 		direction="fixed">
				<value>"request"</value>
			</parameter>
			<parameter name="ontology" class="String" 			direction="fixed">
				<value>"jadex.tools.logger"</value>
			</parameter>
			<parameter name="language" class="String" 			direction="fixed">
				<value>SFipa.JADEX_XML</value>
			</parameter>
		</messageevent> -->
		
      <messageevent name="component_inform" type="fipa" direction="receive">
			<parameter name="performative" class="String" direction="fixed">
				<value>"inform"</value>
			</parameter>
            <parameter name="ontology" class="String" direction="fixed">
                <value>"jadex.tools"</value>
            </parameter>
			<parameter name="language" class="String" direction="fixed">
				<value>SFipa.JADEX_XML</value>
			</parameter>
		</messageevent> 

	</events>

	<properties>
		<!-- <property name="logging.level">java.util.logging.Level.WARNING</property> -->
<!--		<property name="debugging">true</property>-->
	</properties>

	<configurations>
		<configuration name="default">
			<capabilities>
				<initialcapability ref="cms" configuration="componentlist"/>
			</capabilities>
			<beliefs>
				<initialbelief ref="jcc">
					<!-- @me: ich habe den distributionmonitor zusätzlich eingefügt, den die Sever-Plattform braucht, um den momentanen Zustand der verteilen Plattform anzeigen zu können. Eine Client-Plattform braucht keine GUI, lädt also auch keinen JCC.agent.xml Agenten, der eine GUI für einen menschlichen Benutzer aufbauen würde. -->
					<fact>
						<!-- new jadex.distributed.tools.jcc.AgentControlCenter($scope.getServiceContainer(), --> <!-- TODO evtl. kann der package prefix wegfallen, wenn ich den jadex/tool/startet aus runtimetools nach distributed kopiert habe -->
						new AgentControlCenter($scope.getServiceContainer(),
						"jadex.tools.starter.StarterPlugin" <!-- eigenes StarterPlugin nötig, damit das AgentControlCenter aus distributed, und nicht aus runtime-tools geladen wird; das AgentControlCenter aus distributed nutzt dann auch das ControlCenter aus distributed beim extends -->
						<!--"jadex.distributed.tools.starter.StarterPlugin" -->
						+" jadex.tools.dfbrowser.DFBrowserPlugin"
						+" jadex.tools.convcenter.ConversationPlugin"
						+" jadex.tools.comanalyzer.ComanalyzerPlugin"
						+" jadex.tools.testcenter.TestCenterPlugin"
					//	+" jadex.tools.jadexdoc.JadexdocPlugin"
						+" jadex.tools.simcenter.SimCenterPlugin"
					//	+" jadex.tools.introspector.IntrospectorPlugin"
						+" jadex.tools.debugger.DebuggerPlugin"
						+" jadex.tools.ruleprofiler.RuleProfilerPlugin"
						+" jadex.distributed.tools.distributionmonitor.DistributionMonitorPlugin" <!-- @me: diese Zeile habe ich eingefügt -->
						+" jadex.tools.libtool.LibraryPlugin",
						$scope.getExternalAccess())
					</fact>
				</initialbelief>
			</beliefs>
		</configuration>
	</configurations>

</agent>
